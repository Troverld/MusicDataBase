 
 
========== .bsp\sbt.json ========== 
{"name":"sbt","version":"1.10.11","bspVersion":"2.1.0-M1","languages":["scala"],"argv":["C:\\Users\\30990\\.jdks\\corretto-22.0.2/bin/java","-Xms100m","-Xmx100m","-classpath","C:/Users/30990/AppData/Roaming/JetBrains/IntelliJIdea2025.1/plugins/Scala/launcher/sbt-launch.jar","-Dsbt.script=C:\\Program%20Files%20(x86)\\sbt\\bin\\sbt.bat","xsbt.boot.Boot","-bsp"]} 
========== End of .bsp\sbt.json ========== 
 
========== .gitignore ========== 
*.idea
target/*
project/*
artifacts/*
*.un~
*.MF
*.log
*.jar
!lib/
*.bat
*.csv
!project/Dependencies.scala
!project/plugins.sbt
*.xlsx
#macOS
.DS_Store
*.icloud
remote-version.txt
.bsp
version.txt
null
AA
.metals
.vscode
.bloop 
========== End of .gitignore ========== 
 
========== build.sbt ========== 
ThisBuild / version := "0.1.0-SNAPSHOT"
ThisBuild / scalaVersion := "3.4.2"

scriptClasspath := Seq("*")

assembly / assemblyMergeStrategy := {
  case PathList("module-info.class") => MergeStrategy.discard
  case PathList("META-INF", "versions", xs @ _, "module-info.class") => MergeStrategy.discard
  case PathList("META-INF", "io.netty.versions.properties") => MergeStrategy.first

  // 保留 PostgresSQL 驱动服务文件
  case PathList("META-INF", "services", "java.sql.Driver") => MergeStrategy.concat

  // 以下是常见的其他冲突处理策略
  case x if x.endsWith("/module-info.class") => MergeStrategy.discard
  case PathList("META-INF", xs @ _*) => MergeStrategy.discard
  case "reference.conf" => MergeStrategy.concat
  case _ => MergeStrategy.first
}

assembly / mainClass := Some("Process.Server")
enablePlugins(JavaAppPackaging)


// 不发布源码和文档
Compile / packageDoc / publishArtifact := false
Compile / packageSrc / publishArtifact := false
Compile / run / fork := true

resolvers ++= Seq(
  "Aliyun Central" at "https://maven.aliyun.com/repository/central",
  "Huawei Mirror" at "https://repo.huaweicloud.com/repository/maven/",
  "Tsinghua Mirror" at "https://mirrors.tuna.tsinghua.edu.cn/maven-central/",
  // 官方 Maven Central 仓库
  Resolver.mavenCentral
)

Universal / packageBin / mappings ++= {
  val baseDir = baseDirectory.value
  Seq(
    baseDir / "server_config.json" -> "server_config.json",
  )
}



lazy val root = (project in file("."))
  .settings(
    name := "MusicService",
    // 添加编码设置
    javacOptions ++= Seq("-encoding", "UTF-8"),
    scalacOptions ++= Seq("-encoding", "UTF-8"),
  )

val http4sVersion = "1.0.0-M44"
val circeVersion = "0.14.10"
Compile / run / fork := true

libraryDependencies ++= Seq(

  // http4s 核心库
  "org.http4s" %% "http4s-dsl" % http4sVersion,
  "org.http4s" %% "http4s-ember-server" % http4sVersion,
  "org.http4s" %% "http4s-ember-client" % http4sVersion,
  "org.http4s" %% "http4s-circe" % http4sVersion,

  // Circe 库
  "io.circe" %% "circe-core" % circeVersion,
  "io.circe" %% "circe-generic" % circeVersion,
  "io.circe" %% "circe-parser" % circeVersion,
  "io.circe" %% "circe-yaml" % "1.15.0",

  // 日志库
  "org.typelevel" %% "log4cats-core" % "2.7.0",
  "org.typelevel" %% "log4cats-slf4j" % "2.7.0",
  "ch.qos.logback" % "logback-classic" % "1.5.16",

  // STTP 客户端（现在主要是azure再用）
  "com.softwaremill.sttp.client3" %% "core" % "3.10.3",
  "com.softwaremill.sttp.client3" %% "async-http-client-backend-cats" % "3.10.3",
  "com.softwaremill.sttp.client3" %% "fs2" % "3.10.3",
  "com.softwaremill.sttp.client3" %% "circe" % "3.10.3",

  // FS2 库
  "co.fs2" %% "fs2-core" % "3.11.0", // 添加 fs2 核心库
  "co.fs2" %% "fs2-io" % "3.11.0", // fs2 IO 支持

  // 其他库
  "joda-time" % "joda-time" % "2.12.7",
  "org.eclipse.jgit" % "org.eclipse.jgit" % "5.13.0.202109080827-r",
  "com.zaxxer" % "HikariCP" % "5.1.0",
  "org.postgresql" % "postgresql" % "42.7.2",

  //  "org.scalameta" %% "scalameta" % "4.13.2",
)

// 引入 jackson 辅助 json 序列化
libraryDependencies ++= Seq(
  "com.fasterxml.jackson.core" % "jackson-databind" % "2.15.2",
  "com.fasterxml.jackson.module" %% "jackson-module-scala" % "2.15.2"
) 
========== End of build.sbt ========== 
 
========== project\build.properties ========== 
sbt.version=1.10.11
 
========== End of project\build.properties ========== 
 
========== project\plugins.sbt ========== 
addSbtPlugin("com.github.sbt" % "sbt-native-packager" % "1.11.1")
addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "2.1.5") 
========== End of project\plugins.sbt ========== 
 
========== projectInfo.yaml ========== 

projectID: RLSpNOHKHHGjwQsBsiFn
serviceName: MusicService
versionID: 203
commitID: 9e2c1a2843b7b53a254d2103545c6f873f9f8102
          
========== End of projectInfo.yaml ========== 
 
========== server_config.json ========== 
{
  "serverIP": "127.0.0.1",
  "maximumServerConnection": 10000,
  "maximumClientConnection": 10000,
  "gitlabHost": "http://10.1.18.188:2000",
  "gitlabNameSpace": "repos",
  "jdbcUrl":  "jdbc:postgresql://localhost:5432/",
  "username": "db",
  "password": "root",
  "prepStmtCacheSize": 250,
  "prepStmtCacheSqlLimit":  2048,
  "maximumPoolSize": 10,
  "connectionLiveMinutes": 10,
  "isTest": false
} 
========== End of server_config.json ========== 
 
========== src\main\scala\APIs\CreatorService\AddArtistManager.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * AddArtistManager
 * desc: 
 * @param adminID: String (发出操作的管理员ID)
 * @param adminToken: String (发出操作的管理员令牌)
 * @param userID: String (要加入管理者列表的用户)
 * @param artistID: String (要新增管理者的艺术家)
 */

case class AddArtistManager(
  adminID: String,
  adminToken: String,
  userID: String,
  artistID: String
) extends API[(Boolean, String)](CreatorServiceCode)



case object AddArtistManager{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[AddArtistManager] = deriveEncoder
  private val circeDecoder: Decoder[AddArtistManager] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[AddArtistManager] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[AddArtistManager] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[AddArtistManager]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given addArtistManagerEncoder: Encoder[AddArtistManager] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given addArtistManagerDecoder: Decoder[AddArtistManager] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\AddArtistManager.scala ========== 
 
========== src\main\scala\APIs\CreatorService\AddBandManager.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * AddBandManager
 * desc: 
 * @param adminID: String (发出操作的管理员ID)
 * @param adminToken: String (发出操作的管理员令牌)
 * @param userID: String (要加入管理者列表的用户)
 * @param bandID: String (要新增管理者的乐队)
 */

case class AddBandManager(
  adminID: String,
  adminToken: String,
  userID: String,
  bandID: String
) extends API[(Boolean, String)](CreatorServiceCode)



case object AddBandManager{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[AddBandManager] = deriveEncoder
  private val circeDecoder: Decoder[AddBandManager] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[AddBandManager] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[AddBandManager] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[AddBandManager]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given addBandManagerEncoder: Encoder[AddBandManager] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given addBandManagerDecoder: Decoder[AddBandManager] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\AddBandManager.scala ========== 
 
========== src\main\scala\APIs\CreatorService\CreateArtistMessage.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * CreateArtistMessage
 * desc: 创建新的艺术家信息
 * @param adminID: String (管理员ID)
 * @param adminToken: String (管理员令牌)
 * @param name: String (艺术家名称)
 * @param bio: String (艺术家简介)
 * @return (Option[String], String): (新建的艺术家ID, 错误信息)
 */

case class CreateArtistMessage(
  adminID: String,
  adminToken: String,
  name: String,
  bio: String
) extends API[(Option[String], String)](CreatorServiceCode)



case object CreateArtistMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[CreateArtistMessage] = deriveEncoder
  private val circeDecoder: Decoder[CreateArtistMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[CreateArtistMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[CreateArtistMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[CreateArtistMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given createArtistMessageEncoder: Encoder[CreateArtistMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given createArtistMessageDecoder: Decoder[CreateArtistMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\CreateArtistMessage.scala ========== 
 
========== src\main\scala\APIs\CreatorService\CreateBandMessage.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * CreateBandMessage
 * desc: 创建新的乐队信息
 * @param adminID: String (管理员ID)
 * @param adminToken: String (管理员令牌)
 * @param name: String (乐队名称)
 * @param members: List[String] (乐队成员ID列表)
 * @param bio: String (乐队简介)
 * @return (Option[String], String): (新建的乐队ID, 错误信息)
 */

case class CreateBandMessage(
  adminID: String,
  adminToken: String,
  name: String,
  members: List[String],
  bio: String
) extends API[(Option[String], String)](CreatorServiceCode)



case object CreateBandMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[CreateBandMessage] = deriveEncoder
  private val circeDecoder: Decoder[CreateBandMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[CreateBandMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[CreateBandMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[CreateBandMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given createBandMessageEncoder: Encoder[CreateBandMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given createBandMessageDecoder: Decoder[CreateBandMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\CreateBandMessage.scala ========== 
 
========== src\main\scala\APIs\CreatorService\DeleteArtistMessage.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * DeleteArtistMessage
 * desc: 删除指定艺术家信息
 * @param adminID: String (管理员ID)
 * @param adminToken: String (管理员令牌)
 * @param artistID: String (艺术家ID)
 * @return (Boolean, String): (删除是否成功, 错误信息)
 */

case class DeleteArtistMessage(
  adminID: String,
  adminToken: String,
  artistID: String
) extends API[(Boolean, String)](CreatorServiceCode)



case object DeleteArtistMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[DeleteArtistMessage] = deriveEncoder
  private val circeDecoder: Decoder[DeleteArtistMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[DeleteArtistMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[DeleteArtistMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[DeleteArtistMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given deleteArtistMessageEncoder: Encoder[DeleteArtistMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given deleteArtistMessageDecoder: Decoder[DeleteArtistMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\DeleteArtistMessage.scala ========== 
 
========== src\main\scala\APIs\CreatorService\DeleteBandMessage.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * DeleteBandMessage
 * desc: 删除指定乐队信息
 * @param adminID: String (管理员ID，确保操作者身份为有权限用户。)
 * @param adminToken: String (管理员令牌，确保本次操作的有效性。)
 * @param bandID: String (待删除的乐队ID。)
 * @return (Boolean, String): (删除是否成功, 错误信息)
 */

case class DeleteBandMessage(
  adminID: String,
  adminToken: String,
  bandID: String
) extends API[(Boolean, String)](CreatorServiceCode)



case object DeleteBandMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[DeleteBandMessage] = deriveEncoder
  private val circeDecoder: Decoder[DeleteBandMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[DeleteBandMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[DeleteBandMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[DeleteBandMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given deleteBandMessageEncoder: Encoder[DeleteBandMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given deleteBandMessageDecoder: Decoder[DeleteBandMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\DeleteBandMessage.scala ========== 
 
========== src\main\scala\APIs\CreatorService\UpdateArtistMessage.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UpdateArtistMessage
 * desc: 更新现有艺术家信息
 * @param userID: String (当前用户的ID，用于操作验证)
 * @param userToken: String (用户令牌，用于验证用户身份和权限)
 * @param artistID: String (需要更新的艺术家唯一标识)
 * @param name: Option[String] (新艺术家名称，可选)
 * @param bio: Option[String] (新艺术家简介，可选)
 * @return (Boolean, String): (更新是否成功, 错误信息)
 */

case class UpdateArtistMessage(
  userID: String,
  userToken: String,
  artistID: String,
  name: Option[String] = None,
  bio: Option[String] = None
) extends API[(Boolean, String)](CreatorServiceCode)



case object UpdateArtistMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UpdateArtistMessage] = deriveEncoder
  private val circeDecoder: Decoder[UpdateArtistMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UpdateArtistMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UpdateArtistMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UpdateArtistMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given updateArtistMessageEncoder: Encoder[UpdateArtistMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given updateArtistMessageDecoder: Decoder[UpdateArtistMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\UpdateArtistMessage.scala ========== 
 
========== src\main\scala\APIs\CreatorService\UpdateBandMessage.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UpdateBandMessage
 * desc: 更新现有乐队的信息接口
 * @param userID: String (用户ID，用于标识请求用户)
 * @param userToken: String (用户令牌，用于校验用户身份)
 * @param bandID: String (乐队的唯一标识ID)
 * @param name: Option[String] (乐队的新名称（可选）)
 * @param members: List[String] (乐队成员ID列表（可选）)
 * @param bio: Option[String] (乐队新的简介信息（可选）)
 * @return (Boolean, String): (更新是否成功, 错误信息)
 */

case class UpdateBandMessage(
  userID: String,
  userToken: String,
  bandID: String,
  name: Option[String] = None,
  members: Option[List[String]] = None,
  bio: Option[String] = None
) extends API[(Boolean, String)](CreatorServiceCode)



case object UpdateBandMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UpdateBandMessage] = deriveEncoder
  private val circeDecoder: Decoder[UpdateBandMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UpdateBandMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UpdateBandMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UpdateBandMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given updateBandMessageEncoder: Encoder[UpdateBandMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given updateBandMessageDecoder: Decoder[UpdateBandMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\UpdateBandMessage.scala ========== 
 
========== src\main\scala\APIs\CreatorService\validArtistOwnership.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * validArtistOwnership
 * desc: 验证某用户是否拥有对指定艺术家的管理权限
 * @param userID: String (用户ID)
 * @param userToken: String (用户Token)
 * @param artistID: String (艺术家ID)
 * @return (Boolean, String): (用户是否拥有权限, 错误信息)
 */

case class validArtistOwnership(
  userID: String,
  userToken: String,
  artistID: String
) extends API[(Boolean, String)](CreatorServiceCode)



case object validArtistOwnership{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[validArtistOwnership] = deriveEncoder
  private val circeDecoder: Decoder[validArtistOwnership] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[validArtistOwnership] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[validArtistOwnership] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[validArtistOwnership]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given validArtistOwnershipEncoder: Encoder[validArtistOwnership] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given validArtistOwnershipDecoder: Decoder[validArtistOwnership] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\validArtistOwnership.scala ========== 
 
========== src\main\scala\APIs\CreatorService\validBandOwnership.scala ========== 
package APIs.CreatorService

import Common.API.API
import Global.ServiceCenter.CreatorServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * validBandOwnership
 * desc: 验证某用户是否拥有对指定乐队的管理权限
 * @param userID: String (用户ID)
 * @param userToken: String (用户令牌，用于验证用户身份有效性)
 * @param bandID: String (乐队ID)
 * @return (Boolean, String): (用户是否拥有权限, 错误信息)
 */

case class validBandOwnership(
  userID: String,
  userToken: String,
  bandID: String
) extends API[(Boolean, String)](CreatorServiceCode)



case object validBandOwnership{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[validBandOwnership] = deriveEncoder
  private val circeDecoder: Decoder[validBandOwnership] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[validBandOwnership] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[validBandOwnership] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[validBandOwnership]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given validBandOwnershipEncoder: Encoder[validBandOwnership] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given validBandOwnershipDecoder: Decoder[validBandOwnership] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\CreatorService\validBandOwnership.scala ========== 
 
========== src\main\scala\APIs\MusicService\CreateNewGenre.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * CreateNewGenre
 * desc: 创建一个新的曲风记录。
 * @param adminID: String (管理员ID，用于验证权限。)
 * @param adminToken: String (管理员的认证令牌。)
 * @param name: String (曲风名称。)
 * @param description: String (曲风的描述信息。)
 * @return (Option[String], String): (生成的新曲风ID, 错误信息)
 */

case class CreateNewGenre(
  adminID: String,
  adminToken: String,
  name: String,
  description: String
) extends API[(Option[String], String)](MusicServiceCode)



case object CreateNewGenre{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[CreateNewGenre] = deriveEncoder
  private val circeDecoder: Decoder[CreateNewGenre] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[CreateNewGenre] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[CreateNewGenre] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[CreateNewGenre]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given createNewGenreEncoder: Encoder[CreateNewGenre] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given createNewGenreDecoder: Decoder[CreateNewGenre] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\CreateNewGenre.scala ========== 
 
========== src\main\scala\APIs\MusicService\DeleteGenre.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * DeleteGenre
 * desc: 删除曲风信息，仅限管理员操作
 * @param adminID: String (管理员的唯一标识符)
 * @param adminToken: String (管理员身份验证令牌，用于权限校验)
 * @param genreID: String (要删除的曲风ID)
 * @return (Boolean, String): (删除是否成功, 错误信息)
 */

case class DeleteGenre(
  adminID: String,
  adminToken: String,
  genreID: String
) extends API[(Boolean, String)](MusicServiceCode)



case object DeleteGenre{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[DeleteGenre] = deriveEncoder
  private val circeDecoder: Decoder[DeleteGenre] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[DeleteGenre] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[DeleteGenre] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[DeleteGenre]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given deleteGenreEncoder: Encoder[DeleteGenre] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given deleteGenreDecoder: Decoder[DeleteGenre] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\DeleteGenre.scala ========== 
 
========== src\main\scala\APIs\MusicService\DeleteSong.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * DeleteSong
 * desc: 用于管理员删除指定歌曲信息。
 * @param adminID: String (管理员ID，用于进行身份验证。)
 * @param adminToken: String (管理员验证令牌，用于鉴权。)
 * @param songID: String (待删除的歌曲ID。)
 * @return (Boolean, String): (删除是否成功, 错误信息)
 */

case class DeleteSong(
  adminID: String,
  adminToken: String,
  songID: String
) extends API[(Boolean, String)](MusicServiceCode)



case object DeleteSong{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[DeleteSong] = deriveEncoder
  private val circeDecoder: Decoder[DeleteSong] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[DeleteSong] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[DeleteSong] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[DeleteSong]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given deleteSongEncoder: Encoder[DeleteSong] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given deleteSongDecoder: Decoder[DeleteSong] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\DeleteSong.scala ========== 
 
========== src\main\scala\APIs\MusicService\FilterSongsByEntity.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * FilterSongsByEntity
 * desc: 按照实体（artist/band）或曲风筛选歌曲。
 * @param userID: String (用户的唯一标识。)
 * @param userToken: String (用于验证用户身份的令牌。)
 * @param entityID: Option[String] (实体（艺术家或乐队）的唯一ID，可选。)
 * @param entityType: Option[String] (实体的类型: 'artist' 或 'band'，可选。)
 * @param genres: Option[String] (曲风ID列表，可选，表示筛选曲风。)
 * @return (Option[List[String]], String): (符合条件的歌曲ID列表, 错误信息)
 */

case class FilterSongsByEntity(
  userID: String,
  userToken: String,
  entityID: Option[String] = None,
  entityType: Option[String] = None,
  genres: Option[String] = None
) extends API[(Option[List[String]], String)](MusicServiceCode)



case object FilterSongsByEntity{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[FilterSongsByEntity] = deriveEncoder
  private val circeDecoder: Decoder[FilterSongsByEntity] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[FilterSongsByEntity] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[FilterSongsByEntity] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[FilterSongsByEntity]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given filterSongsByEntityEncoder: Encoder[FilterSongsByEntity] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given filterSongsByEntityDecoder: Decoder[FilterSongsByEntity] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\FilterSongsByEntity.scala ========== 
 
========== src\main\scala\APIs\MusicService\SearchSongsByName.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * SearchSongsByName
 * desc: 根据歌曲名称搜索匹配的歌曲列表，用于歌曲检索功能。
 * @param userID: String (当前用户的ID，用于权限和用户会话的匹配验证。)
 * @param userToken: String (当前用户的令牌，用于身份认证和权限验证。)
 * @param keywords: String (用户输入的模糊搜索关键词，用于匹配歌曲名称。)
 * @return (Option[List[String]], String): (匹配到的歌曲ID列表, 错误信息)
 */

case class SearchSongsByName(
  userID: String,
  userToken: String,
  keywords: String
) extends API[(Option[List[String]], String)](MusicServiceCode)



case object SearchSongsByName{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[SearchSongsByName] = deriveEncoder
  private val circeDecoder: Decoder[SearchSongsByName] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[SearchSongsByName] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[SearchSongsByName] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[SearchSongsByName]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given searchSongsByNameEncoder: Encoder[SearchSongsByName] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given searchSongsByNameDecoder: Decoder[SearchSongsByName] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\SearchSongsByName.scala ========== 
 
========== src\main\scala\APIs\MusicService\UpdateSongMetadata.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UpdateSongMetadata
 * desc: 更新已有的歌曲信息，包括元数据和相关引用信息。
 * @param userID: String (进行更新操作的用户ID)
 * @param userToken: String (用于验证用户的访问令牌)
 * @param songID: String (需要更新的歌曲ID)
 * @param name: Option[String] (需要更新的歌曲名称)
 * @param releaseTime: Option[DateTime] (需要更新的歌曲发布时间)
 * @param creators: List[String] (需要更新的创作者列表)
 * @param performers: List[String] (需要更新的演唱者列表)
 * @param lyricists: List[String] (需要更新的作词者列表)
 * @param composers: List[String] (需要更新的作曲者列表)
 * @param arrangers: List[String] (需要更新的编曲者列表)
 * @param instrumentalists: List[String] (需要更新的演奏者列表)
 * @param genres: List[String] (需要更新的歌曲曲风列表)
 * @return (Boolean, String): (更新是否成功, 错误信息)
 */

case class UpdateSongMetadata(
  userID: String,
  userToken: String,
  songID: String,
  name: Option[String] = None,
  releaseTime: Option[DateTime] = None,
  creators: Option[List[String]] = None,
  performers: Option[List[String]] = None,
  lyricists: Option[List[String]] = None,
  composers: Option[List[String]] = None,
  arrangers: Option[List[String]] = None,
  instrumentalists: Option[List[String]] = None,
  genres: Option[List[String]] = None
) extends API[(Boolean, String)](MusicServiceCode)



case object UpdateSongMetadata{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UpdateSongMetadata] = deriveEncoder
  private val circeDecoder: Decoder[UpdateSongMetadata] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UpdateSongMetadata] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UpdateSongMetadata] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UpdateSongMetadata]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given updateSongMetadataEncoder: Encoder[UpdateSongMetadata] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given updateSongMetadataDecoder: Decoder[UpdateSongMetadata] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\UpdateSongMetadata.scala ========== 
 
========== src\main\scala\APIs\MusicService\UploadNewSong.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UploadNewSong
 * desc: 上传新歌曲的接口。
 * @param userID: String (用户ID，用于标识当前操作用户。)
 * @param userToken: String (用户令牌，用于验证用户身份。)
 * @param name: String (歌曲名称。)
 * @param releaseTime: DateTime (歌曲的发布日期。)
 * @param creators: List[String] (创作者ID列表。)
 * @param performers: List[String] (演唱者ID列表。)
 * @param lyricists: List[String] (作词者ID列表。)
 * @param arrangers: List[String] (编曲者ID列表。)
 * @param instrumentalists: List[String] (演奏者ID列表。)
 * @param genres: List[String] (曲风ID列表，用于标识歌曲的归类。)
 * @param composers: List[String] (作曲者ID列表。)
 * @return (Option[String], String): (生成的歌曲ID, 错误信息)
 */

case class UploadNewSong(
  userID: String,
  userToken: String,
  name: String,
  releaseTime: DateTime,
  creators: List[String],
  performers: List[String],
  lyricists: List[String],
  arrangers: List[String],
  instrumentalists: List[String],
  genres: List[String],
  composers: List[String]
) extends API[(Option[String], String)](MusicServiceCode)



case object UploadNewSong{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UploadNewSong] = deriveEncoder
  private val circeDecoder: Decoder[UploadNewSong] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UploadNewSong] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UploadNewSong] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UploadNewSong]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given uploadNewSongEncoder: Encoder[UploadNewSong] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given uploadNewSongDecoder: Decoder[UploadNewSong] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\UploadNewSong.scala ========== 
 
========== src\main\scala\APIs\MusicService\ValidateSongOwnership.scala ========== 
package APIs.MusicService

import Common.API.API
import Global.ServiceCenter.MusicServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * ValidateSongOwnership
 * desc: 验证用户是否对指定歌曲拥有管理权限
 * @param userID: String (用户ID，用于验证用户身份和权限)
 * @param userToken: String (用户令牌，用于验证用户身份有效性)
 * @param songID: String (歌曲ID，用于标识需要验证的歌曲)
 * @return (Boolean, String): (用户是否拥有管理权限, 错误信息)
 */

case class ValidateSongOwnership(
  userID: String,
  userToken: String,
  songID: String
) extends API[(Boolean, String)](MusicServiceCode)



case object ValidateSongOwnership{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[ValidateSongOwnership] = deriveEncoder
  private val circeDecoder: Decoder[ValidateSongOwnership] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[ValidateSongOwnership] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[ValidateSongOwnership] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[ValidateSongOwnership]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given validateSongOwnershipEncoder: Encoder[ValidateSongOwnership] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given validateSongOwnershipDecoder: Decoder[ValidateSongOwnership] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\MusicService\ValidateSongOwnership.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\ApproveArtistAuthRequestMessage.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * ApproveArtistAuthRequestMessage
 * desc: 管理员审核绑定艺术家的请求
 * @param adminID: String (管理员ID)
 * @param adminToken: String (管理员认证令牌)
 * @param requestID: String (绑定请求的唯一标识)
 * @param approve: Boolean (是否批准该绑定申请)
 * @return (Boolean, String): (审核是否成功, 错误信息)
 */

case class ApproveArtistAuthRequestMessage(
  adminID: String,
  adminToken: String,
  requestID: String,
  approve: Boolean
) extends API[(Boolean, String)](OrganizeServiceCode)



case object ApproveArtistAuthRequestMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[ApproveArtistAuthRequestMessage] = deriveEncoder
  private val circeDecoder: Decoder[ApproveArtistAuthRequestMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[ApproveArtistAuthRequestMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[ApproveArtistAuthRequestMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[ApproveArtistAuthRequestMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given approveArtistAuthRequestMessageEncoder: Encoder[ApproveArtistAuthRequestMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given approveArtistAuthRequestMessageDecoder: Decoder[ApproveArtistAuthRequestMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\ApproveArtistAuthRequestMessage.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\ApproveBandAuthRequestMessage.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * ApproveBandAuthRequestMessage
 * desc: 管理员审核一个绑定乐队的请求，用于管理员角色管理绑定申请
 * @param adminID: String (管理员的唯一标识)
 * @param adminToken: String (管理员的认证令牌，用于验证身份)
 * @param requestID: String (乐队绑定申请的唯一请求ID)
 * @param approve: Boolean (审核结果，true表示通过，false表示拒绝)
 * @return (Boolean, String): (审核是否成功, 错误信息)
 */

case class ApproveBandAuthRequestMessage(
  adminID: String,
  adminToken: String,
  requestID: String,
  approve: Boolean
) extends API[(Boolean, String)](OrganizeServiceCode)



case object ApproveBandAuthRequestMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[ApproveBandAuthRequestMessage] = deriveEncoder
  private val circeDecoder: Decoder[ApproveBandAuthRequestMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[ApproveBandAuthRequestMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[ApproveBandAuthRequestMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[ApproveBandAuthRequestMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given approveBandAuthRequestMessageEncoder: Encoder[ApproveBandAuthRequestMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given approveBandAuthRequestMessageDecoder: Decoder[ApproveBandAuthRequestMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\ApproveBandAuthRequestMessage.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\SubmitArtistAuthRequestMessage.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * SubmitArtistAuthRequestMessage
 * desc: 用户提交艺术家绑定申请
 * @param userID: String (用户的唯一标识)
 * @param userToken: String (用户的令牌，用于身份验证)
 * @param artistID: String (艺术家的唯一标识)
 * @param certification: String (认证证据，用于验证绑定申请的合法性)
 * @return (Option[String], String): (生成的绑定申请记录的唯一标识, 错误信息)
 */

case class SubmitArtistAuthRequestMessage(
  userID: String,
  userToken: String,
  artistID: String,
  certification: String
) extends API[(Option[String], String)](OrganizeServiceCode)



case object SubmitArtistAuthRequestMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[SubmitArtistAuthRequestMessage] = deriveEncoder
  private val circeDecoder: Decoder[SubmitArtistAuthRequestMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[SubmitArtistAuthRequestMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[SubmitArtistAuthRequestMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[SubmitArtistAuthRequestMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given submitArtistAuthRequestMessageEncoder: Encoder[SubmitArtistAuthRequestMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given submitArtistAuthRequestMessageDecoder: Decoder[SubmitArtistAuthRequestMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\SubmitArtistAuthRequestMessage.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\SubmitBandAuthRequestMessage.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * SubmitBandAuthRequestMessage
 * desc: 用户提交乐队绑定申请
 * @param userID: String (用户ID，用于标识提交申请的用户)
 * @param userToken: String (用户令牌，用于校验用户身份)
 * @param bandID: String (乐队ID，用于标识用户申请绑定的乐队)
 * @param certification: String (认证证据，用于证明用户与乐队的关联性)
 * @return (Option[String], String): (申请ID, 错误信息)
 */

case class SubmitBandAuthRequestMessage(
  userID: String,
  userToken: String,
  bandID: String,
  certification: String
) extends API[(Option[String], String)](OrganizeServiceCode)



case object SubmitBandAuthRequestMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[SubmitBandAuthRequestMessage] = deriveEncoder
  private val circeDecoder: Decoder[SubmitBandAuthRequestMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[SubmitBandAuthRequestMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[SubmitBandAuthRequestMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[SubmitBandAuthRequestMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given submitBandAuthRequestMessageEncoder: Encoder[SubmitBandAuthRequestMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given submitBandAuthRequestMessageDecoder: Decoder[SubmitBandAuthRequestMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\SubmitBandAuthRequestMessage.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\UserLoginMessage.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UserLoginMessage
 * desc: 用户传入用户名和加密后的密码，完成登录认证，并获得一个时间敏感的用户令牌
 * @param userName: String (用户名，用于标识具体用户)
 * @param hashedPassword: String (加密后的密码，用于验证用户身份)
 * @return (Option[String], String): (用户登录令牌, 错误信息)
 */

case class UserLoginMessage(
  userName: String,
  hashedPassword: String
) extends API[(Option[String], String)](OrganizeServiceCode)



case object UserLoginMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UserLoginMessage] = deriveEncoder
  private val circeDecoder: Decoder[UserLoginMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UserLoginMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UserLoginMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UserLoginMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given userLoginMessageEncoder: Encoder[UserLoginMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given userLoginMessageDecoder: Decoder[UserLoginMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\UserLoginMessage.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\UserLogoutMessage.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UserLogoutMessage
 * desc: 用户传入自身ID和当前token，完成登出操作
 * @param userID: String (用户ID，标识用户身份)
 * @param userToken: String (用户令牌，用于验证登录的状态和身份)
 * @return (Boolean, String): (登出是否成功, 错误信息)
 */

case class UserLogoutMessage(
  userID: String,
  userToken: String
) extends API[(Boolean, String)](OrganizeServiceCode)



case object UserLogoutMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UserLogoutMessage] = deriveEncoder
  private val circeDecoder: Decoder[UserLogoutMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UserLogoutMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UserLogoutMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UserLogoutMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given userLogoutMessageEncoder: Encoder[UserLogoutMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given userLogoutMessageDecoder: Decoder[UserLogoutMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\UserLogoutMessage.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\UserRegisterMessage.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UserRegisterMessage
 * desc: 用户注册操作接口，用户通过用户名和密码完成注册，并分配唯一ID
 * @param userName: String (用户名，用于标识唯一用户账户)
 * @param password: String (用户密码，用于账户安全验证，需加密存储)
 * @return (Option[String], String): (成功时的用户ID或None表示失败；失败时的报错信息)
 */

case class UserRegisterMessage(
  userName: String,
  password: String
) extends API[(Option[String], String)](OrganizeServiceCode)



case object UserRegisterMessage{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UserRegisterMessage] = deriveEncoder
  private val circeDecoder: Decoder[UserRegisterMessage] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UserRegisterMessage] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UserRegisterMessage] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UserRegisterMessage]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given userRegisterMessageEncoder: Encoder[UserRegisterMessage] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given userRegisterMessageDecoder: Decoder[UserRegisterMessage] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\UserRegisterMessage.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\ValidateAdminMapping.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * ValidateAdminMapping
 * desc: 统一验证管理员的有效性、映射关系和权限，用于所有涉及管理员操作的功能作为前置验证
 * @param adminID: String (管理员ID)
 * @param adminToken: String (管理员令牌)
 * @return (Boolean, String): (管理员是否通过验证, 错误信息)
 */

case class ValidateAdminMapping(
  adminID: String,
  adminToken: String
) extends API[(Boolean, String)](OrganizeServiceCode)



case object ValidateAdminMapping{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[ValidateAdminMapping] = deriveEncoder
  private val circeDecoder: Decoder[ValidateAdminMapping] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[ValidateAdminMapping] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[ValidateAdminMapping] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[ValidateAdminMapping]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given ValidateAdminMappingEncoder: Encoder[ValidateAdminMapping] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given ValidateAdminMappingDecoder: Decoder[ValidateAdminMapping] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\ValidateAdminMapping.scala ========== 
 
========== src\main\scala\APIs\OrganizeService\ValidateUserMapping.scala ========== 
package APIs.OrganizeService

import Common.API.API
import Global.ServiceCenter.OrganizeServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * ValidateUserMapping
 * desc: 统一验证用户的有效性和映射关系
 * @param userID: String (用户ID，用于标识当前进行验权操作的用户)
 * @param userToken: String (用户令牌，用于验证用户登录及验证有效性)
 * @return (Boolean, String): (用户ID与令牌是否匹配且有效, 错误信息)
 */

case class ValidateUserMapping(
  userID: String,
  userToken: String
) extends API[(Boolean, String)](OrganizeServiceCode)



case object ValidateUserMapping{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[ValidateUserMapping] = deriveEncoder
  private val circeDecoder: Decoder[ValidateUserMapping] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[ValidateUserMapping] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[ValidateUserMapping] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[ValidateUserMapping]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given ValidateUserMappingEncoder: Encoder[ValidateUserMapping] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given ValidateUserMappingDecoder: Decoder[ValidateUserMapping] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\OrganizeService\ValidateUserMapping.scala ========== 
 
========== src\main\scala\APIs\TrackService\AddToPlaylist.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * AddToPlaylist
 * desc: 通过 playlistID 和 songIDs 向播放集添加歌曲，用于在用户的播放集中追加歌曲。
 * @param userID: String (执行操作的用户的唯一标识符)
 * @param userToken: String (用户的身份验证令牌，用于验证用户合法性)
 * @param playlistID: String (播放列表的唯一标识符，用于指定目标播放列表)
 * @param songIDs: List[String] (需要添加到播放列表的歌曲ID列表)
 * @return (Boolean, String): (操作是否成功, 错误信息)
 */

case class AddToPlaylist(
  userID: String,
  userToken: String,
  playlistID: String,
  songIDs: List[String]
) extends API[(Boolean, String)](TrackServiceCode)



case object AddToPlaylist{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[AddToPlaylist] = deriveEncoder
  private val circeDecoder: Decoder[AddToPlaylist] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[AddToPlaylist] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[AddToPlaylist] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[AddToPlaylist]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given addToPlaylistEncoder: Encoder[AddToPlaylist] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given addToPlaylistDecoder: Decoder[AddToPlaylist] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\AddToPlaylist.scala ========== 
 
========== src\main\scala\APIs\TrackService\CreateAlbum.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * CreateAlbum
 * desc: 创建新的专辑，用于管理员创建专辑
 * @param adminID: String (管理员ID，用于验证管理员身份)
 * @param adminToken: String (管理员令牌，用于验证管理员权限)
 * @param name: String (专辑名称)
 * @param description: String (专辑简介)
 * @param releaseTime: DateTime (专辑发布的时间)
 * @param creators: List[String] (创作者ID列表，必须包含至少一个有效的Artist或Band ID)
 * @param collaborators: List[String] (协作者ID列表，包含协助创作的Artist或Band ID)
 * @param contents: List[String] (歌曲ID列表，表示专辑中包含的歌曲)
 * @return (Option[String], String): (生成的专辑ID, 错误信息)
 */

case class CreateAlbum(
  adminID: String,
  adminToken: String,
  name: String,
  description: String,
  releaseTime: DateTime,
  creators: List[String],
  collaborators: List[String],
  contents: List[String]
) extends API[(Option[String], String)](TrackServiceCode)



case object CreateAlbum{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[CreateAlbum] = deriveEncoder
  private val circeDecoder: Decoder[CreateAlbum] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[CreateAlbum] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[CreateAlbum] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[CreateAlbum]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given createAlbumEncoder: Encoder[CreateAlbum] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given createAlbumDecoder: Decoder[CreateAlbum] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\CreateAlbum.scala ========== 
 
========== src\main\scala\APIs\TrackService\CreateCollection.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * CreateCollection
 * desc: 创建新的歌单，用于用户自定义歌单的创建
 * @param userID: String (当前操作的用户ID，确保调用者身份)
 * @param userToken: String (用户令牌，用于验证用户的合法性)
 * @param name: String (歌单的名称，不能为空)
 * @param description: String (歌单的简介，用于描述歌单的内容和信息)
 * @param contents: List[String] (歌单包含的歌曲ID列表)
 * @return (Option[String], String): (新生成的歌单ID, 错误信息)
 */

case class CreateCollection(
  userID: String,
  userToken: String,
  name: String,
  description: String,
  contents: List[String]
) extends API[(Option[String], String)](TrackServiceCode)



case object CreateCollection{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[CreateCollection] = deriveEncoder
  private val circeDecoder: Decoder[CreateCollection] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[CreateCollection] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[CreateCollection] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[CreateCollection]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given createCollectionEncoder: Encoder[CreateCollection] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given createCollectionDecoder: Decoder[CreateCollection] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\CreateCollection.scala ========== 
 
========== src\main\scala\APIs\TrackService\DeleteAlbum.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * DeleteAlbum
 * desc: 删除专辑，仅管理员能够删除专辑。
 * @param adminID: String (管理员用户的唯一标识符)
 * @param adminToken: String (管理员身份验证令牌，用以确认操作合法性)
 * @param albumID: String (需要删除的专辑的唯一标识符)
 * @return (Boolean, String): (操作是否成功, 错误信息)
 */

case class DeleteAlbum(
  adminID: String,
  adminToken: String,
  albumID: String
) extends API[(Boolean, String)](TrackServiceCode)



case object DeleteAlbum{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[DeleteAlbum] = deriveEncoder
  private val circeDecoder: Decoder[DeleteAlbum] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[DeleteAlbum] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[DeleteAlbum] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[DeleteAlbum]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given deleteAlbumEncoder: Encoder[DeleteAlbum] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given deleteAlbumDecoder: Decoder[DeleteAlbum] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\DeleteAlbum.scala ========== 
 
========== src\main\scala\APIs\TrackService\DeleteCollection.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * DeleteCollection
 * desc: 删除某个歌单，仅管理员可删除歌单
 * @param adminID: String (管理员ID，用于身份验证)
 * @param adminToken: String (管理员令牌，验证权限有效性)
 * @param collectionID: String (需要删除的歌单的唯一ID)
 * @return (Boolean, String): (操作是否成功, 错误信息)
 */

case class DeleteCollection(
  adminID: String,
  adminToken: String,
  collectionID: String
) extends API[(Boolean, String)](TrackServiceCode)



case object DeleteCollection{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[DeleteCollection] = deriveEncoder
  private val circeDecoder: Decoder[DeleteCollection] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[DeleteCollection] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[DeleteCollection] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[DeleteCollection]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given deleteCollectionEncoder: Encoder[DeleteCollection] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given deleteCollectionDecoder: Decoder[DeleteCollection] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\DeleteCollection.scala ========== 
 
========== src\main\scala\APIs\TrackService\InviteMaintainerToCollection.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * InviteMaintainerToCollection
 * desc: 邀请某用户成为歌单的维护者，用于扩展歌单管理权限。
 * @param userID: String (当前发起邀请操作的用户ID，需要拥有歌单的管理权限。)
 * @param userToken: String (当前用户的API访问令牌，用于验证操作合法性。)
 * @param collectionID: String (歌单对应的唯一标识符。)
 * @param invitedUserID: String (被邀请的用户ID，新的歌单维护者。)
 * @return (Boolean, String): (操作是否成功, 错误信息)
 */

case class InviteMaintainerToCollection(
  userID: String,
  userToken: String,
  collectionID: String,
  invitedUserID: String
) extends API[(Boolean, String)](TrackServiceCode)



case object InviteMaintainerToCollection{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[InviteMaintainerToCollection] = deriveEncoder
  private val circeDecoder: Decoder[InviteMaintainerToCollection] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[InviteMaintainerToCollection] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[InviteMaintainerToCollection] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[InviteMaintainerToCollection]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given inviteMaintainerToCollectionEncoder: Encoder[InviteMaintainerToCollection] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given inviteMaintainerToCollectionDecoder: Decoder[InviteMaintainerToCollection] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\InviteMaintainerToCollection.scala ========== 
 
========== src\main\scala\APIs\TrackService\UpdateAlbum.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UpdateAlbum
 * desc: 更新专辑信息，用于更新专辑的内容与元数据
 * @param userID: String (发起动作的用户ID)
 * @param userToken: String (用户令牌，用于身份验证)
 * @param albumID: String (专辑唯一标识符)
 * @param name: Option[String] (专辑名称，可选字段)
 * @param description: Option[String] (专辑简介，可选字段)
 * @param creators: List[String]
 * @param collaborators: List[String] (协作者ID列表，可选字段)
 * @param contents: List[String] (专辑包含的歌曲ID列表)
 * @return (Boolean, String): (操作是否成功, 错误信息)
 */

case class UpdateAlbum(
  userID: String,
  userToken: String,
  albumID: String,
  name: Option[String] = None,
  description: Option[String] = None,
  creators: Option[List[String]] = None,
  collaborators: Option[List[String]] = None,
  contents: Option[List[String]] = None
) extends API[(Boolean, String)](TrackServiceCode)



case object UpdateAlbum{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UpdateAlbum] = deriveEncoder
  private val circeDecoder: Decoder[UpdateAlbum] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UpdateAlbum] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UpdateAlbum] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UpdateAlbum]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given updateAlbumEncoder: Encoder[UpdateAlbum] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given updateAlbumDecoder: Decoder[UpdateAlbum] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\UpdateAlbum.scala ========== 
 
========== src\main\scala\APIs\TrackService\UpdateCollection.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * UpdateCollection
 * desc: 通过 collectionID 修改歌单信息，如歌单名称、简介、内容、维护者，用于对用户创建的歌单进行更新操作。
 * @param userID: String (当前操作用户的ID。)
 * @param userToken: String (当前操作用户的身份令牌，用于身份校验。)
 * @param collectionID: String (歌单ID，用于标识待更新的歌单。)
 * @param name: Option[String] (新的歌单名称，可选字段。)
 * @param description: Option[String] (新的歌单简介，可选字段。)
 * @param contents: List[String] (新的歌单内容，即包含的歌曲ID列表，可选字段。)
 * @param maintainers: List[String] (新的维护者ID列表，可选字段。)
 * @return (Boolean, String): (操作是否成功, 错误信息)
 */

case class UpdateCollection(
  userID: String,
  userToken: String,
  collectionID: String,
  name: Option[String] = None,
  description: Option[String] = None,
  contents: Option[List[String]] = None,
  maintainers: Option[List[String]] = None
) extends API[(Boolean, String)](TrackServiceCode)



case object UpdateCollection{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[UpdateCollection] = deriveEncoder
  private val circeDecoder: Decoder[UpdateCollection] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[UpdateCollection] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[UpdateCollection] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[UpdateCollection]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given updateCollectionEncoder: Encoder[UpdateCollection] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given updateCollectionDecoder: Decoder[UpdateCollection] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\UpdateCollection.scala ========== 
 
========== src\main\scala\APIs\TrackService\validateAlbumOwnership.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * validateAlbumOwnership
 * desc: 验证用户是否对专辑具有管理权限，用于 UpdateAlbum 和相关操作的权限验证
 * @param userID: String (用户ID，用于表示请求的用户。)
 * @param userToken: String (用户令牌，用于验证用户身份有效性)
 * @param albumID: String (专辑ID，对应需要验证权限的专辑。)
 * @return (Boolean, String): (用户是否具有对该专辑的管理权限, 错误信息)
 */

case class validateAlbumOwnership(
  userID: String,
  userToken: String,
  albumID: String
) extends API[(Boolean, String)](TrackServiceCode)



case object validateAlbumOwnership{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[validateAlbumOwnership] = deriveEncoder
  private val circeDecoder: Decoder[validateAlbumOwnership] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[validateAlbumOwnership] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[validateAlbumOwnership] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[validateAlbumOwnership]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given validateAlbumOwnershipEncoder: Encoder[validateAlbumOwnership] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given validateAlbumOwnershipDecoder: Decoder[validateAlbumOwnership] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\validateAlbumOwnership.scala ========== 
 
========== src\main\scala\APIs\TrackService\validateCollectionOwnership.scala ========== 
package APIs.TrackService

import Common.API.API
import Global.ServiceCenter.TrackServiceCode

import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * validateCollectionOwnership
 * desc: 验证用户是否为某歌单的所有者或维护者
 * @param userID: String (用户的唯一标识符，用于验证用户权限)
 * @param userToken: String (用户令牌，用于验证用户身份有效性)
 * @param collectionID: String (歌单的唯一标识符，用于指定某个歌单)
 * @return (Boolean, String): (用户是否为歌单的所有者或维护者, 错误信息)
 */

case class validateCollectionOwnership(
  userID: String,
  userToken: String,
  collectionID: String
) extends API[(Boolean, String)](TrackServiceCode)



case object validateCollectionOwnership{
    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[validateCollectionOwnership] = deriveEncoder
  private val circeDecoder: Decoder[validateCollectionOwnership] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[validateCollectionOwnership] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[validateCollectionOwnership] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[validateCollectionOwnership]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given validateCollectionOwnershipEncoder: Encoder[validateCollectionOwnership] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given validateCollectionOwnershipDecoder: Decoder[validateCollectionOwnership] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\APIs\TrackService\validateCollectionOwnership.scala ========== 
 
========== src\main\scala\Common\API\API.scala ========== 
package Common.API

import Common.DBAPI.DidRollbackException
import Common.ServiceUtils.getURI
import cats.data.NonEmptyList
import cats.effect.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder, Json}
import org.http4s.*
import org.http4s.Uri.Path
import org.http4s.circe.*
import org.http4s.circe.CirceEntityDecoder.*
import org.http4s.client.Client
import org.http4s.ember.client.EmberClientBuilder
import org.typelevel.ci.CIString
import org.typelevel.log4cats.slf4j.{Slf4jFactory, Slf4jLogger}
import org.typelevel.log4cats.{Logger, LoggerFactory}

import scala.concurrent.duration.DurationInt

implicit val loggerFactory: LoggerFactory[IO] = Slf4jFactory.create[IO]

import scala.compiletime.erasedValue

/** API的基本类型，保存了API返回的数据类型 ReturnType */
abstract class API[T: Decoder](targetService: String):
  type ReturnType = T

  /** 表示当前API是否会产生回复。如果不会产生回复，则这里会复写成false */
  inline def hasReply: Boolean =
    inline erasedValue[ReturnType] match
      case _: Unit => true
      case _ => false

  def getURIWithAPIMessageName: IO[Uri] =
    for {
      baseUri <- getURI(targetService)
      newPath = baseUri.path.concat(Path.unsafeFromString("/api/" + this.getClass.getSimpleName.stripPrefix("/")))
      updatedUri = baseUri.withPath(newPath)
    } yield updatedUri

  def send(using Encoder[this.type], PlanContext): IO[T] = API.send[T, this.type](this)

object API {
  trait ResponseHandler[T]:
    def handle(response: Response[IO]): IO[T]

  given ResponseHandler[String] with
    def handle(response: Response[IO]): IO[String] = response.bodyText.compile.string

  given [T: Decoder]: ResponseHandler[T] with
    def handle(response: Response[IO]): IO[T] = {
      response.asJsonDecode[T].flatMap {
        IO(_)
      }
    }

  private var client: Option[Client[IO]] = None

  def init(maximumClientConnection: Int): IO[Unit] = {
    val clientResource: Resource[IO, Client[IO]] = EmberClientBuilder.default[IO]
      .withMaxTotal(maximumClientConnection)
      .withTimeout(30.seconds)
      .withIdleConnectionTime(30.seconds)
      .build

    clientResource.use { httpClient =>
      IO {
        client = Some(httpClient)
      }
    }
  }

  private given logger: Logger[IO] = Slf4jLogger.getLogger[IO]

  def send[T: Decoder, A <: API[T] : Encoder](message: A)(using context: PlanContext): IO[T] =
    for {
      _ <- logger.info(s"Preparing to send message ${message}")
      uri <- message.getURIWithAPIMessageName
      modifiedJson = message.asJson.mapObject { jsonObj =>
        val planContext = Json.obj(
          "traceID" -> context.traceID.asJson,
          "transactionLevel" -> Json.fromInt(context.transactionLevel)
        )
        jsonObj.add("planContext", planContext)
      }
      request = Request[IO](Method.POST, uri).withEntity(modifiedJson)

      result <- client.get.run(request).use { response =>
        val handler = summon[ResponseHandler[T]] // Summon an instance of ResponseHandler for T
        val rollbackHeader: Option[NonEmptyList[Header.Raw]] = response.headers.get(CIString("X-DidRollback"))

        response.status match {
          case status if status.isSuccess =>
            response.bodyText.compile.string.flatMap { body =>
              IO.println(s"Response body: $body")
            } >>
              handler.handle(response)
          case _ =>
            response.bodyText.compile.string.flatMap { body =>
              rollbackHeader match {
                case Some(header) =>
                  IO.raiseError(DidRollbackException(body))
                case _ =>
                  IO.raiseError(new Exception(s"Unexpected response status: ${response.status.code}, body: $body"))
              }
            }
        }
      }
    } yield result
} 
========== End of src\main\scala\Common\API\API.scala ========== 
 
========== src\main\scala\Common\API\MessageSerializer.scala ========== 
package Common.API

import io.circe.Encoder
import io.circe.syntax.*

trait MessageSerializer[T] {
  def toMessage(t: T): String
}

given AutoSerializer[T](using encoder: Encoder[T]): MessageSerializer[T] with
  def toMessage(t: T): String = t.asJson.noSpaces

 
========== End of src\main\scala\Common\API\MessageSerializer.scala ========== 
 
========== src\main\scala\Common\API\PlanContext.scala ========== 
package Common.API

case class PlanContext(traceID:TraceID, transactionLevel: Int)
 
========== End of src\main\scala\Common\API\PlanContext.scala ========== 
 
========== src\main\scala\Common\API\Planner.scala ========== 
package Common.API

import Common.DBAPI.startTransaction
import cats.effect.IO
import io.circe.Encoder

trait Planner[ReturnType]:
  def plan(using planContext: PlanContext): IO[ReturnType]

  def planWithErrorControl(using planContext:PlanContext, encoder: Encoder[ReturnType]):IO[ReturnType]=
    startTransaction{
      plan
    }.onError{e=>
      errorRecovery>>  //这里会运行定制化的error recovery
      IO.println("error:"+e)
    }

  /** 默认是不做任何error recovery的。但是如果在文件系统中出了问题，应该需要调用writeToLocalGitMessage把local的内容重置一遍才对 */
  def errorRecovery(using planContext:PlanContext):IO[Unit]=IO.unit

  def fullPlan(using encoder: Encoder[ReturnType]): IO[ReturnType] =
    IO.println(this) >> planWithErrorControl(using this.planContext, encoder)

  val planContext: PlanContext = PlanContext(TraceID(""), 0)
 
========== End of src\main\scala\Common\API\Planner.scala ========== 
 
========== src\main\scala\Common\API\TraceID.scala ========== 
package Common.API

import io.circe.*
import io.circe.generic.semiauto.*


case class TraceID(id:String):
  override def toString: String = id

object TraceID {
  implicit val encodeTraceID: Encoder[TraceID] = Encoder.encodeString.contramap[TraceID](_.toString)
  implicit val decodeTraceID: Decoder[TraceID] = Decoder.decodeString.emap { str =>Right(TraceID(str))}
} 
========== End of src\main\scala\Common\API\TraceID.scala ========== 
 
========== src\main\scala\Common\Constants.scala ========== 
package Common


object Constants {
  val masterBranch: String = "master"

  val basicScalaTypes: List[String] = List("String","Boolean", "Int", "Long", "Float", "Double")
  val basicTsTypes: List[String] = List("string", "number", "boolean")


  val scalaTimeImportStr: String = "import org.joda.time.DateTime"
  val scalaTimeType: String = "DateTime"
  val parameterTimeType: String = "datetime"
  val scalaTimeTypeSet: Seq[String] = List(scalaTimeType, parameterTimeType)
}
 
========== End of src\main\scala\Common\Constants.scala ========== 
 
========== src\main\scala\Common\DBAPI\DidRollbackException.scala ========== 
package Common.DBAPI

/** 这个Exception表示之前已经处理过RollBack的问题了 */
case class DidRollbackException(text:String) extends Exception(text)
 
========== End of src\main\scala\Common\DBAPI\DidRollbackException.scala ========== 
 
========== src\main\scala\Common\DBAPI\EndTransactionMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Global.ServiceCenter.tongWenDBServiceCode

case class EndTransactionMessage(commit: Boolean) extends API[String](tongWenDBServiceCode) 
========== End of src\main\scala\Common\DBAPI\EndTransactionMessage.scala ========== 
 
========== src\main\scala\Common\DBAPI\InitSchemaMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Global.ServiceCenter.tongWenDBServiceCode
import io.circe.generic.auto.*

case class InitSchemaMessage(schemaName: String) extends API[String](tongWenDBServiceCode) 
========== End of src\main\scala\Common\DBAPI\InitSchemaMessage.scala ========== 
 
========== src\main\scala\Common\DBAPI\package.scala ========== 
package Common

import Common.API.{PlanContext, TraceID}
import Global.DBConfig
import Common.Object.{ParameterList, SqlParameter}
import DBAPI.{EndTransactionMessage, InitSchemaMessage, ReadDBRowsMessage, ReadDBValueMessage, StartTransactionMessage, WriteDBListMessage, WriteDBMessage}
import cats.effect.*
import io.circe.{Decoder, Encoder, HCursor, Json}
import io.circe.generic.auto.*
import org.joda.time.DateTime
import io.circe.parser.decode
import org.http4s.client.Client
import org.joda.time.format.ISODateTimeFormat


package object DBAPI {

  def startTransaction[A](block: PlanContext ?=> IO[A])(using encoder: Encoder[A], ctx: PlanContext): IO[A] = {
    given newContext: PlanContext = ctx.copy(transactionLevel = ctx.transactionLevel + 1)

    // Define the start transaction action
    val startTransactionAction = if (ctx.transactionLevel == 0) {
      StartTransactionMessage().send
    } else {
      IO.unit // No action needed, already inside a transaction
    }

    def commitOrRollbackAction(result: Either[Throwable, A]): IO[A] =
      result match {
        case Left(exception:DidRollbackException) =>
          IO.raiseError(exception)   /** 如果问题已经处理过了，我们不需要额外处理了 */
        case Left(exception)=>
          EndTransactionMessage(false).send >> IO.raiseError(DidRollbackException(exception.getMessage)) // 出现了问题，回滚
        case Right(value) =>
          if (ctx.transactionLevel == 0)
            /** 除非是第一层，否则是不把事务结束的 */
            EndTransactionMessage(true).send.as(value)
          else IO.pure(value)
      }

    for {
      _ <- startTransactionAction // Start the transaction if this is the first level
      result <- block(using newContext).attempt // Execute the block with the new (incremented) transaction context
      _ <- IO.println("Step result")

      _ <- result match
        case Left(value) => IO.pure(value.printStackTrace())
        case Right(value) => IO.println(s"result = ${result}")

      finalResult <- commitOrRollbackAction(result)
    } yield finalResult
  }

  def rollback(): IO[Unit] = IO.raiseError(RollbackException("Rollback"))

  def initSchema(schemaName: String)(using planContext:PlanContext): IO[String] = InitSchemaMessage(schemaName).send

  def readDBRows(sqlQuery: String, parameters: List[SqlParameter])(using PlanContext): IO[List[Json]] =
    ReadDBRowsMessage(sqlQuery, parameters).send
    
  def readDBJson(sqlQuery: String, parameters: List[SqlParameter])(using PlanContext): IO[Json] =
    ReadDBRowsMessage(sqlQuery, parameters).send.map(_.head)

  def readDBJsonOptional(sqlQuery: String, parameters: List[SqlParameter])(using PlanContext): IO[Option[Json]] =
    ReadDBRowsMessage(sqlQuery, parameters).send.map(_.headOption)

  def readDBInt(sqlQuery: String, parameters: List[SqlParameter])(using context: PlanContext): IO[Int] =
    for {
      resultParam: String<- ReadDBValueMessage(sqlQuery, parameters).send
      convertedResult = resultParam.toInt
    } yield convertedResult

  def readDBString(sqlQuery: String, parameters: List[SqlParameter])(using context: PlanContext): IO[String] =
    for {
      resultParam: String<- ReadDBValueMessage(sqlQuery, parameters).send
    } yield resultParam

  def readDBBoolean(sqlQuery: String, parameters: List[SqlParameter])(using context: PlanContext): IO[Boolean] =
    for {
      resultParam: String<- ReadDBValueMessage(sqlQuery, parameters).send
      convertedResult = resultParam.startsWith("t")
    } yield convertedResult

  def writeDB(sqlQuery: String, parameters: List[SqlParameter])(using PlanContext): IO[String] = WriteDBMessage(sqlQuery, parameters).send

  def writeDBList(sqlQuery: String, parameters: List[ParameterList])(using PlanContext): IO[String] = WriteDBListMessage(sqlQuery, parameters).send

  def decodeField[T: Decoder](json:Json, field:String):T={
    json.hcursor.downField(snakeToCamel(field)).as[T].fold(throw _, value=>value)
  }
  def decodeType[T:Decoder](json:Json):T={
    json.as[T].fold(throw _, value=>value)
  }
  def decodeTypeIO[T:Decoder](json:Json):IO[T]={
    json.as[T].fold(IO.raiseError, IO.pure)
  }
  def decodeType[T:Decoder](st:String):T={
    decode[T](st).fold(throw _, value=>value)
  }
  def decodeTypeIO[T:Decoder](st:String):IO[T]={
    decode[T](st).fold(IO.raiseError, IO.pure)
  }

  def snakeToCamel(snake: String): String = {
    snake.split("_").toList match {
      case head :: tail =>
        head + tail.map {
          case "id" => "ID"
          case other => other.capitalize
        }.mkString
      case Nil => ""
    }
  }
}
 
========== End of src\main\scala\Common\DBAPI\package.scala ========== 
 
========== src\main\scala\Common\DBAPI\ReadDBRowsMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Common.Object.SqlParameter
import Global.ServiceCenter.tongWenDBServiceCode
import io.circe.Json


// Assuming Row and TraceID are defined elsewhere
case class ReadDBRowsMessage(sqlQuery: String, parameters: List[SqlParameter]) extends API[List[Json]](tongWenDBServiceCode) 
========== End of src\main\scala\Common\DBAPI\ReadDBRowsMessage.scala ========== 
 
========== src\main\scala\Common\DBAPI\ReadDBValueMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Common.Object.SqlParameter
import Global.ServiceCenter.tongWenDBServiceCode
import io.circe.Decoder
import io.circe.generic.semiauto.*

case class ReadDBValueMessage(sqlQuery: String, parameters: List[SqlParameter]) extends API[String](tongWenDBServiceCode)
 
========== End of src\main\scala\Common\DBAPI\ReadDBValueMessage.scala ========== 
 
========== src\main\scala\Common\DBAPI\RollbackException.scala ========== 
package Common.DBAPI

case class RollbackException(message: String) extends Exception(message)
 
========== End of src\main\scala\Common\DBAPI\RollbackException.scala ========== 
 
========== src\main\scala\Common\DBAPI\StartTransactionMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Global.ServiceCenter.tongWenDBServiceCode

// StartTransactionMessage case class
case class StartTransactionMessage() extends API[String](tongWenDBServiceCode) 
========== End of src\main\scala\Common\DBAPI\StartTransactionMessage.scala ========== 
 
========== src\main\scala\Common\DBAPI\SwitchDataSourceMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Global.ServiceCenter.tongWenDBServiceCode

case class SwitchDataSourceMessage(projectName: String) extends API[String](tongWenDBServiceCode) 
========== End of src\main\scala\Common\DBAPI\SwitchDataSourceMessage.scala ========== 
 
========== src\main\scala\Common\DBAPI\WriteDBListMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Common.Object.ParameterList
import Global.ServiceCenter.tongWenDBServiceCode

case class WriteDBListMessage(sqlStatement: String, parameters: List[ParameterList]) extends API[String](tongWenDBServiceCode) 
========== End of src\main\scala\Common\DBAPI\WriteDBListMessage.scala ========== 
 
========== src\main\scala\Common\DBAPI\WriteDBMessage.scala ========== 
package Common.DBAPI

import Common.API.API
import Common.Object.SqlParameter
import Global.ServiceCenter.tongWenDBServiceCode

case class WriteDBMessage(sqlStatement: String, parameters: List[SqlParameter]) extends API[String](tongWenDBServiceCode) 
========== End of src\main\scala\Common\DBAPI\WriteDBMessage.scala ========== 
 
========== src\main\scala\Common\EnvUtils.scala ========== 
package Common

/**
 * 获取系统的环境变量
 *
 * 需要配置 dockerfile、gitlab-ci.yml 才能获取到当前的环境信息（分支信息）
 * 可参考 clinic-hub / clinic-server 的配置
 *
 * - gitlab-ci.yml => --build-arg CI_COMMIT_BRANCH="${CI_COMMIT_BRANCH}"
 * - dockerfile => ARG CI_COMMIT_BRANCH; ENV CI_COMMIT_BRANCH=${CI_COMMIT_BRANCH}
 *
 */
object EnvUtils {

  val k8sEnvKey = "CI_COMMIT_BRANCH"

  val localEnv = "localhost"
  val test1Env = "test1"
  val masterEnv = "master"
  val devEnv = "dev"

  val defaultEnv = "localhost"
  val featEnvPrefix = "feat"

  def getEnv: String = getEnvVar(k8sEnvKey, defaultEnv)
  def getEnv(defaultEnv: String): String = getEnvVar(k8sEnvKey, defaultEnv)
  def getEnvVar(keyName: String, defaultVal: String): String = System.getenv().getOrDefault(keyName, defaultVal)

  def isFeatBranch: Boolean = getEnv.startsWith(featEnvPrefix)

}
 
========== End of src\main\scala\Common\EnvUtils.scala ========== 
 
========== src\main\scala\Common\IOUtils.scala ========== 
package Common

import cats.effect.IO
import io.circe.{Decoder, DecodingFailure, Encoder, Json, JsonObject}
import org.joda.time.DateTime
import org.joda.time.format.ISODateTimeFormat

object IOUtils {
  def addTypeField(json: Json, typeName: String): Json =
    json.asObject match {
      case Some(jsonObject) => // If the json can be converted to a JsonObject
        Json.fromJsonObject(jsonObject.add("type", Json.fromString(typeName)))
      case None => 
        json 
    }
  def raiseError(st:String): IO[String]=
    throw new Exception(st)
    
  def assertIO(assertion: Boolean, message: String): IO[Unit] =
    if !assertion then throw Exception(message)
    else IO.unit

  given encodeDateTime: Encoder[DateTime] = Encoder.instance { dateTime =>
    Json.fromLong(dateTime.getMillis)
  }

  given decodeDateTime: Decoder[DateTime] = Decoder.instance { cursor =>
    cursor.as[Long].map(new DateTime(_))
  }
}
 
========== End of src\main\scala\Common\IOUtils.scala ========== 
 
========== src\main\scala\Common\Object\IDClass.scala ========== 
package Common.Object

import io.circe.{Decoder, Encoder}

case class IDClass(v: Long)

object IDClass {

  import Common.Serialize.CustomColumnTypes.{decodeIDClassBase, encodeIDClassBase}

  implicit val encodeIDClass: Encoder[IDClass] = encodeIDClassBase[IDClass]
  implicit val decodeIDClass: Decoder[IDClass] = decodeIDClassBase[IDClass](using IDClass.apply)
}
 
========== End of src\main\scala\Common\Object\IDClass.scala ========== 
 
========== src\main\scala\Common\Object\ParameterList.scala ========== 
package Common.Object

case class ParameterList(l:List[SqlParameter])
 
========== End of src\main\scala\Common\Object\ParameterList.scala ========== 
 
========== src\main\scala\Common\Object\SqlParameter.scala ========== 
package Common.Object

import io.circe.generic.semiauto.deriveEncoder
import io.circe.{Decoder, Encoder, HCursor}

// Define the SqlParam case class
case class SqlParameter(dataType: String, value: String)

object SqlParameter {
  // Encoder for SqlParam
  implicit val encodeSqlParameter: Encoder[SqlParameter] = deriveEncoder[SqlParameter]

  // Decoder for SqlParam
  implicit val decodeSqlParameter: Decoder[SqlParameter] = new Decoder[SqlParameter] {
    final def apply(c: HCursor): Decoder.Result[SqlParameter] = for {
      dataType <- c.downField("dataType").as[String]
      value <- c.downField("value").as[String]
    } yield {
      dataType.toLowerCase match {
        case "string" => SqlParameter("String", value)
        case "int" => SqlParameter("Int", value)
        case "boolean" => SqlParameter("Boolean", value)
        case "long" => SqlParameter("Long", value)
        case "datetime" => SqlParameter("DateTime", value) // Add case for DateTime
        case "array[int]" => SqlParameter("Array[Int]", value) // Add case for Array[Int]
        case "array[string]" => SqlParameter("Array[String]", value) // Add case for Array[Int]
        // Add more type cases as needed
        case s => throw new Exception(s"Unsupported data type ${s}")
      }
    }
  }
} 
========== End of src\main\scala\Common\Object\SqlParameter.scala ========== 
 
========== src\main\scala\Common\package.scala ========== 
import io.circe.{Decoder, Encoder}
import org.joda.time.DateTime

package object Common {

  // LocalDateTime 与 时间戳(Long) 转换的 encoder/decoder
  given localDateTimeEncoder: Encoder[DateTime] =
    Encoder.encodeLong.contramap[DateTime] { dateTime =>
      dateTime.getMillis
    }

  given localDateTimeDecoder: Decoder[DateTime] =
    Decoder.decodeLong.emap { millis =>
      try {
        Right(new DateTime(millis))
      } catch {
        case e: Exception => Left("LocalDateTime parsing error: " + e.getMessage)
      }
    }

}
 
========== End of src\main\scala\Common\package.scala ========== 
 
========== src\main\scala\Common\ParamUtils.scala ========== 
package Common

case object ParamUtils {

  def require(requirement: Boolean, errMsg: String = ""): Unit = {
    if (!requirement)
      throw IllegalArgumentException(errMsg)
  }

  def require(requirement: Boolean, ex: Exception): Unit = {
    if (!requirement)
      throw ex
  }


}
 
========== End of src\main\scala\Common\ParamUtils.scala ========== 
 
========== src\main\scala\Common\ReplyMessage.scala ========== 
package Common

/** 一个general 的reply message，包含了状态与信息和uuid。
  * status默认是0，即是正常的回复。
  * uuid默认是空，是因为我们希望uuid都是系统自动填写的，不需要人手工填写 */
case class ReplyMessage(status:Int, info: String, var uuid:String="") 
========== End of src\main\scala\Common\ReplyMessage.scala ========== 
 
========== src\main\scala\Common\Serialize\CirceSerializable.scala ========== 
package Common.Serialize

import io.circe.{Decoder, Encoder}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}

trait CirceSerializable

 
========== End of src\main\scala\Common\Serialize\CirceSerializable.scala ========== 
 
========== src\main\scala\Common\Serialize\CustomColumnTypes.scala ========== 
package Common.Serialize

import Common.Object.IDClass
import cats.syntax.traverse.*
import io.circe.parser.parse
import io.circe.*
import org.joda.time.DateTime // Import Cats' Either syntax

object CustomColumnTypes {
  given encodeIDClassBase[T <: IDClass]: Encoder[T] = Encoder.instance { idClass =>
    Json.fromInt(idClass.v.toInt) // Store only the `.v` value as an integer
  }

  given decodeIDClassBase[T <: IDClass](using factory: Int => T): Decoder[T] = Decoder.instance { cursor =>
    cursor.as[Int].map(v => factory(v)) // Read the int and create the class
  }

  given genericListDecoder[T<: CirceSerializable](using elementDecoder: Decoder[T]): Decoder[List[T]] = new Decoder[List[T]] {
    final def apply(c: HCursor): Decoder.Result[List[T]] = {
      c.value match {
        case jsonArray if jsonArray.isArray =>
          // Use the base decoder explicitly for decoding the list
          jsonArray.asArray match {
            case Some(array) =>
              array.toList
                .traverse(json => json.as[T](elementDecoder)) // Decode each element explicitly
            case None =>
              Left(DecodingFailure("Expected a JSON array but got something else", c.history))
          }

        case jsonString if jsonString.isString =>
          // Decode from stringified JSON array
          jsonString.as[String].flatMap { str =>
            parse(str) match {
              case Right(parsedJson) =>
                parsedJson.as[List[T]](Decoder.decodeList(elementDecoder)) // Use base decoder for list elements
              case Left(err) =>
                Left(DecodingFailure(s"Failed to parse stringified JSON array: ${err.getMessage}", c.history))
            }
          }

        case _ =>
          // If neither case matches, return a decoding failure
          Left(DecodingFailure("Expected a JSON array or a stringified JSON array", c.history))
      }
    }
  }

  given genericDecoder[T <: CirceSerializable](using baseDecoder: Decoder[T]): Decoder[T] = new Decoder[T] {
    final def apply(c: HCursor): Decoder.Result[T] = {
      println(c.value) // Debugging: print the JSON value being decoded
      c.value match {
        case jsonObject if jsonObject.isObject =>
          baseDecoder(c)

        case jsonString if jsonString.isString =>
          // Decode from stringified JSON
          jsonString.as[String].flatMap { str =>
            parse(str) match {
              case Right(parsedJson) =>
                println(parsedJson) // Debugging: print the parsed JSON
                parsedJson.as[T](baseDecoder) // Pass the base decoder explicitly
              case Left(err) =>
                Left(DecodingFailure(s"Failed to parse stringified JSON: ${err.getMessage}", c.history))
            }
          }

        case _ =>
          // If neither case matches, return a decoding failure
          Left(DecodingFailure("Expected a JSON object or a stringified JSON object", c.history))
      }
    }
  }
  //  given [T <: CirceSerializable](using derive: Decoder[T]): Decoder[T] = genericDecoder[T]

  given encodeDateTime: Encoder[DateTime] = Encoder.instance { dateTime =>
    Json.fromLong(dateTime.getMillis)
  }

  given decodeDateTime: Decoder[DateTime] = Decoder.instance { cursor =>
    cursor.as[Long].map(new DateTime(_))
  }

}
 
========== End of src\main\scala\Common\Serialize\CustomColumnTypes.scala ========== 
 
========== src\main\scala\Common\Serialize\JacksonSerializeUtils.scala ========== 
package Common.Serialize

import Common.API.TraceID
import Common.Object.SqlParameter
import Common.Object.IDClass
import com.fasterxml.jackson.core.`type`.TypeReference
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.databind.{DeserializationFeature, JsonDeserializer, JsonSerializer, ObjectMapper, SerializerProvider}
import com.fasterxml.jackson.module.scala.DefaultScalaModule
import io.circe.{Json, ParsingFailure, parser}
import org.joda.time.DateTime
import org.slf4j.{Logger, LoggerFactory}

case object JacksonSerializeUtils {

  private val log: Logger = LoggerFactory.getLogger(this.getClass.getSimpleName)

  /**
   * 如果一个字段是 String
   * > json 反序列化为对象时, 如果为 null (json-value)，会有类似的报错 - 例如 com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize value of type `java.lang.String` from null
   * > 对象序列化为 json 时，如果属性为 null (object-field)，会序列化为 Null
   */
  lazy val jacksonMapper: ObjectMapper = {
    //序列化器配置 - // 忽略未知字段 - 忽略 class 中没有，但 json 中有的字段
    val mapper = new ObjectMapper()

    def customJacksonModule: SimpleModule = {
      val module = new SimpleModule()
      module.addSerializer(classOf[IDClass], new IDClassSerializer)
      module.addDeserializer(classOf[IDClass], new IDClassDeserializer(id => IDClass(id)))

      module.addSerializer(classOf[DateTime], new DateTimeSerializer)
      module.addDeserializer(classOf[DateTime], new DateTimeDeserializer)

      module.addSerializer(classOf[TraceID], new TraceIDSerializer)
      module.addDeserializer(classOf[TraceID], new TraceIDDeserializer(id => TraceID(id)))

      module
    }

    mapper
      .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
      .registerModule(DefaultScalaModule)
      .registerModule(customJacksonModule) // 注册自定义规则

  }


  def serialize(o: AnyRef): String = {
    jacksonMapper.writeValueAsString(o)
  }

  def serializeToJsonOption(o: AnyRef): Option[Json] = {
    parser.parse(JacksonSerializeUtils.serialize(o)).toOption
  }

  def serializeToJson(o: AnyRef): Json = {
    parser.parse(JacksonSerializeUtils.serialize(o)) match {
      case Left(value: ParsingFailure) =>
        log.error(s"serializeToJson failed, object = ${o}, err = ", value)
        throw new IllegalStateException(s"serializeToJson failed, object = ${o}")

      case Right(value) => value
    }
  }

  def deserialize[T](jsonString: String, typeReference: TypeReference[T]): T = {
    jacksonMapper.readValue(jsonString, typeReference)
  }

}


// IDClass Jackson 序列化
class IDClassSerializer extends JsonSerializer[IDClass] {
  override def serialize(value: IDClass, gen: com.fasterxml.jackson.core.JsonGenerator, serializers: SerializerProvider): Unit = {
    gen.writeNumber(value.v) // 只存 v
  }
}

// IDClass Jackson 反序列化
class IDClassDeserializer[T <: IDClass](factory: Int => T) extends JsonDeserializer[T] {
  override def deserialize(p: com.fasterxml.jackson.core.JsonParser, ctxt: com.fasterxml.jackson.databind.DeserializationContext): T = {
    factory(p.getIntValue) // 从 int 创建对象
  }
}

// ========== DateTime 支持 ==========
class DateTimeSerializer extends JsonSerializer[DateTime] {
  override def serialize(value: DateTime, gen: com.fasterxml.jackson.core.JsonGenerator, serializers: SerializerProvider): Unit = {
    gen.writeNumber(value.getMillis) // 以毫秒存储
  }
}

class DateTimeDeserializer extends JsonDeserializer[DateTime] {
  override def deserialize(p: com.fasterxml.jackson.core.JsonParser, ctxt: com.fasterxml.jackson.databind.DeserializationContext): DateTime = {
    new DateTime(p.getLongValue)
  }
}

// TraceID Jackson 序列化
class TraceIDSerializer extends JsonSerializer[TraceID] {
  override def serialize(value: TraceID, gen: com.fasterxml.jackson.core.JsonGenerator, serializers: SerializerProvider): Unit = {
    gen.writeString(value.id) // 只存 v
  }
}

// TraceID Jackson 反序列化
class TraceIDDeserializer[T <: TraceID](factory: String => T) extends JsonDeserializer[T] {
  override def deserialize(p: com.fasterxml.jackson.core.JsonParser, ctxt: com.fasterxml.jackson.databind.DeserializationContext): T = {
    factory(p.getText()) // 从 int 创建对象
  }
}
 
========== End of src\main\scala\Common\Serialize\JacksonSerializeUtils.scala ========== 
 
========== src\main\scala\Common\Serialize\TWTableTemplateRow.scala ========== 
package Common.Serialize

import Common.API.PlanContext
import Common.ServiceUtils.schemaName
import cats.effect.IO

trait TWTableTemplateRow extends CirceSerializable {

  /***
   * 列归属的表名称
   * @see [[Process.Init.init]]
   */
  def tableName: String

  /**
   * 表初始化的 SQL 语句
   * @see [[Process.Init.init]]
   */
  def initSQL: String

  /**
   * 表初始化的 IO 命令
   */
  def initIO(using PlanContext): IO[Any]

  /**
   * 表全名
   * @return
   */
  def fullTableName: String = s"${schemaName}.${tableName}"
}
 
========== End of src\main\scala\Common\Serialize\TWTableTemplateRow.scala ========== 
 
========== src\main\scala\Common\ServiceUtils.scala ========== 
package Common

import Global.GlobalVariables.serviceCode
import Global.GlobalVariables
import Global.ServiceCenter.fullNameMap
import cats.effect.IO
import com.comcast.ip4s.Port
import org.http4s.Uri


object ServiceUtils{
  def getURI(serviceCode: String): IO[Uri] =
    if (GlobalVariables.isTest)
      IO.fromEither(Uri.fromString(
        s"http://${serviceName(serviceCode).toLowerCase()}:" + getPort(serviceCode).value.toString + "/"
      ))
    else
      IO.fromEither(Uri.fromString(
        "http://localhost:" + getPort(serviceCode).value.toString + "/"
      ))

  def getPort(serviceCode: String): Port =
    Port.fromInt(portMap(serviceCode)).getOrElse(
      throw new IllegalArgumentException(s"Invalid port for serviceCode: $serviceCode")
    )


  def serviceName(serviceCode: String): String = {
    val fullName = fullNameMap(serviceCode)
    val end = fullName.indexOf("（")
    fullNameMap(serviceCode).substring(0, end).toLowerCase
  }

  def portMap(serviceCode: String): Int = {
    serviceCode.drop(1).toInt +
      (if (serviceCode.head == 'A') 10000 else if (serviceCode.head == 'D') 20000 else 30000)
  }


  lazy val servicePort: Int = portMap(serviceCode)
  lazy val serviceFullName: String = fullNameMap(serviceCode)
  lazy val serviceShortName: String = serviceName(serviceCode)
  lazy val schemaName: String = {
    val srcSchemaName = serviceName(serviceCode).replaceAll("-","_")
    EnvUtils.isFeatBranch match {
      case true => srcSchemaName + "_" + EnvUtils.getEnv
      case false => srcSchemaName
    }
  }
}
 
========== End of src\main\scala\Common\ServiceUtils.scala ========== 
 
========== src\main\scala\Common\SqlUtils.scala ========== 
package Common

import scala.util.matching.Regex

object SqlUtils {
  private val validIDentifierPattern: Regex = "^[a-zA-Z_][a-zA-Z0-9_]*$".r
  private val reservedSqlKeywords: Set[String] = Set(
    "SELECT", "INSERT", "UPDATE", "DELETE", "CREATE", "ALTER", "DROP", "TABLE"
    // Add all other reserved SQL keywords that are relevant for your DBMS
  )

  def isTableNameSafe(tableName: String): Boolean = {
    // Split the fully qualified table name into schema and table components
    val parts = tableName.split("\\.", -1)

    // Check that there are either one or two parts (table or schema.table) and all parts are valid
    parts.nonEmpty && parts.length <= 2 && parts.forall { part =>
      validIDentifierPattern.findFirstIn(part).isDefined &&
        !reservedSqlKeywords.contains(part.toUpperCase)
    }
  }
} 
========== End of src\main\scala\Common\SqlUtils.scala ========== 
 
========== src\main\scala\Global\DBConfig.scala ========== 
package Global


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import Common.Serialize.JacksonSerializeUtils
import com.fasterxml.jackson.core.`type`.TypeReference
import scala.util.Try


case class DBConfig(
                     /** 数据库地址，例如：jdbc:postgresql://localhost:5432/db */
                     jdbcUrl: String,

                     /** 用户名 */
                     username: String,

                     /** 密码 */
                     password: String,

                     schemaName: String = Common.ServiceUtils.schemaName,

                     /** 缓存的数据库statement个数 */
                     prepStmtCacheSize: Int = 250,

                     /** 缓存的数据库语句最大长度 */
                     prepStmtCacheSqlLimit: Int = 2048,

                     /** 最多能够保持的连接数目，建议=服务器的CPU核数*2+1 */
                     maximumPoolSize: Int = 36,

                     /** connection的最长存活时间 */
                     connectionLiveMinutes: Int = 8,

                     /** 服务器最多能够同时接受多少请求，这个数字可以大一点防止成为并发的瓶颈 */
                     maximumServerConnection: Int = 20000,
                   )

case object  DBConfig{
  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[DBConfig] = deriveEncoder
  private val circeDecoder: Decoder[DBConfig] = deriveDecoder

  // jackson 对应的 encoder, decoder
  private val jacksonEncoder: Encoder[DBConfig] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[DBConfig] = Decoder.instance{ cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[DBConfig]() {})) }
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }

  // Circe + Jackson 兜底的 Encoder
  given dbConfigEncoder: Encoder[DBConfig] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given dbConfigDecoder: Decoder[DBConfig] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\Global\DBConfig.scala ========== 
 
========== src\main\scala\Global\GlobalVariables.scala ========== 
package Global

import Global.ServiceCenter.*


object GlobalVariables {
  lazy val serviceCode : String = MusicServiceCode
  val projectIDLength:Int=20
  var isTest:Boolean=false

}
 
========== End of src\main\scala\Global\GlobalVariables.scala ========== 
 
========== src\main\scala\Global\ServerConfig.scala ========== 
package Global

import io.circe.{Decoder, Encoder, Json, HCursor}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.generic.auto.*
import Common.Serialize.JacksonSerializeUtils
import com.fasterxml.jackson.core.`type`.TypeReference
import scala.util.Try

/** 配置文件 */
case class ServerConfig(
                         /** 服务器地址 */
                         serverIP: String,

                         /** 服务器端口 */
                         serverPort: Int = Common.ServiceUtils.servicePort,

                         /** 最大连接数 */
                         maximumServerConnection: Int,

                         /** 最大的同时往内部微服务发送的请求个数，原则上和最大连接数相同 */
                         maximumClientConnection: Int,

                         /** 数据库地址，例如：jdbc:postgresql://localhost:5432/db */
                         jdbcUrl: String,

                         /** 用户名 */
                         username: String,

                         /** 密码 */
                         password: String,

                         /** 缓存的数据库statement个数 */
                         prepStmtCacheSize: Int,

                         /** 缓存的数据库语句最大长度 */
                         prepStmtCacheSqlLimit: Int,

                         /** 最多能够保持的连接数目，建议=服务器的CPU核数*2+1 */
                         maximumPoolSize: Int,

                         /** connection的最长存活时间 */
                         connectionLiveMinutes: Int,

                         isTest:Boolean
                       )

case object ServerConfig{

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[ServerConfig] = deriveEncoder
  private val circeDecoder: Decoder[ServerConfig] = deriveDecoder

  // jackson 对应的 encoder, decoder
  private val jacksonEncoder: Encoder[ServerConfig] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[ServerConfig] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[ServerConfig]() {})) }
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history))}
  }

  // Circe + Jackson 兜底的 Encoder
  given dbConfigEncoder: Encoder[ServerConfig] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given dbConfigDecoder: Decoder[ServerConfig] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }

} 
========== End of src\main\scala\Global\ServerConfig.scala ========== 
 
========== src\main\scala\Global\ServiceCenter.scala ========== 
package Global

object ServiceCenter {
  val projectName: String = "PlusUltraMDB"
  val dbManagerServiceCode = "A000001"
  val tongWenDBServiceCode = "A000002"
  val tongWenServiceCode = "A000003"

  val MusicServiceCode = "A000010"
  val OrganizeServiceCode = "A000011"
  val CreatorServiceCode = "A000012"
  val TrackServiceCode = "A000013"

  val fullNameMap: Map[String, String] = Map(
    tongWenDBServiceCode -> "DB-Manager（DB-Manager）",
    tongWenServiceCode -> "Tong-Wen（Tong-Wen）",
    MusicServiceCode -> "MusicService（MusicService)",
    OrganizeServiceCode -> "OrganizeService（OrganizeService)",
    CreatorServiceCode -> "CreatorService（CreatorService)",
    TrackServiceCode -> "TrackService（TrackService)"
  )

  def serviceName(serviceCode: String): String = {
    fullNameMap(serviceCode).toLowerCase
  }
}
 
========== End of src\main\scala\Global\ServiceCenter.scala ========== 
 
========== src\main\scala\Impl\CreateNewGenrePlanner.scala ========== 
package Impl


/**
 * Planner for CreateNewGenre: 创建一个新的曲风记录
 * 输入参数:
 *   - name        : String -> 曲风名称
 *   - description : String -> 曲风简介
 *   - adminID     : String -> 管理员ID
 *   - adminToken  : String -> 管理员Token
 * 输出参数:
 *   - genreID : String -> 新创建曲风的genreID
 */
import APIs.OrganizeService.ValidateAdminMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import org.slf4j.LoggerFactory
import io.circe.Json
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import APIs.OrganizeService.ValidateAdminMapping
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class CreateNewGenrePlanner(
  name: String,
  description: String,
  adminID: String,
  adminToken: String,
  override val planContext: PlanContext
) extends Planner[String] {

  // Logger for debugging and error tracking
  val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using PlanContext): IO[String] = {
    for {
      // Step 1: 验证管理员权限
      _ <- IO(logger.info(s"验证管理员权限: 管理员ID=${adminID}, 管理员Token=${adminToken}"))
      _ <- ValidateAdmin()

      // Step 2.1: 检查曲风名称是否为空
      _ <- IO(logger.info(s"检查曲风名称 ${name} 是否为空"))
      _ <- checkNameNotEmpty()

      // Step 2.2: 检查曲风名称是否已存在
      _ <- IO(logger.info(s"检查曲风名称 ${name} 是否已存在"))
      _ <- checkGenreNameUnique()

      // Step 3: 生成新的曲风ID并插入记录
      _ <- IO(logger.info(s"生成新的曲风ID"))
      genreID <- generateAndInsertGenre()

      _ <- IO(logger.info(s"新曲风创建成功，genreID=${genreID}"))
    } yield genreID
  }

  /**
   * 验证管理员权限
   * Step 1.1: 调用ValidateAdminMapping以验证权限
   * @return IO[Unit]
   */
  private def ValidateAdmin()(using PlanContext): IO[Unit] = {
    ValidateAdminMapping(adminID, adminToken).send.flatMap { isValid =>
      if (isValid) IO(logger.info("管理员权限验证通过"))
      else IO.raiseError(new IllegalStateException("管理员认证失败"))
    }
  }

  /**
   * 检查曲风名称是否为空
   * Step 2.1: 若为空抛出异常
   * @return IO[Unit]
   */
  private def checkNameNotEmpty()(using PlanContext): IO[Unit] = {
    if (name.trim.isEmpty) {
      IO.raiseError(new IllegalArgumentException("名称不能为空"))
    } else {
      IO(logger.info(s"曲风名称 ${name} 不为空"))
    }
  }

  /**
   * 检查曲风名称是否已存在
   * Step 2.2: 在GenreTable中查询是否存在冲突
   * @return IO[Unit]
   */
  private def checkGenreNameUnique()(using PlanContext): IO[Unit] = {
    val sql = s"SELECT COUNT(*) FROM ${schemaName}.genre_table WHERE name = ?"
    readDBInt(sql, List(SqlParameter("String", name))).flatMap { count =>
      if (count > 0) {
        IO.raiseError(new IllegalArgumentException("曲风名称已存在"))
      } else {
        IO(logger.info(s"曲风名称 ${name} 没有重复"))
      }
    }
  }

  /**
   * 生成新的曲风ID并插入数据库中
   * Step 3: 生成唯一genreID并插入GenreTable
   * @return IO[String] -> 生成的genreID
   */
  private def generateAndInsertGenre()(using PlanContext): IO[String] = {
    val newGenreID = java.util.UUID.randomUUID().toString
    val sql =
      s"""
         |INSERT INTO ${schemaName}.genre_table (genre_id, name, description)
         |VALUES (?, ?, ?)
       """.stripMargin
    writeDB(sql, List(
      SqlParameter("String", newGenreID),
      SqlParameter("String", name),
      SqlParameter("String", description)
    )).flatMap { _ =>
      IO(newGenreID)
    }
  }
} 
========== End of src\main\scala\Impl\CreateNewGenrePlanner.scala ========== 
 
========== src\main\scala\Impl\DeleteGenrePlanner.scala ========== 
package Impl


import APIs.OrganizeService.ValidateAdminMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import org.slf4j.LoggerFactory
import org.joda.time.DateTime
import io.circe._
import io.circe.syntax._
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import APIs.OrganizeService.ValidateAdminMapping
import io.circe.generic.auto._
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class DeleteGenrePlanner(
                               genreID: String,
                               adminID: String,
                               adminToken: String,
                               override val planContext: PlanContext
                             ) extends Planner[String] {

  val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using PlanContext): IO[String] = {
    for {
      // Step 1: Validate admin identity and permissions
      _ <- IO(logger.info(s"Validating admin permissions for adminID: ${adminID}."))
      isAdminValid <- ValidateAdminMapping(adminID, adminToken).send
      _ <- if (!isAdminValid) {
        IO.raiseError(new IllegalAccessException(s"Admin validation failed for adminID $adminID"))
      } else IO.unit

      // Step 2: Check if genreID exists in GenreTable
      _ <- IO(logger.info(s"Checking if genreID ${genreID} exists in GenreTable."))
      genreExists <- checkGenreExistence(genreID)
      _ <- if (!genreExists) {
        IO.raiseError(new IllegalArgumentException("曲风不存在"))
      } else IO.unit

      // Step 3: Validate if the genre is referenced by any song
      _ <- IO(logger.info(s"Validating if genreID ${genreID} is referenced in SongTable."))
      isGenreReferenced <- checkGenreUsage(genreID)
      _ <- if (isGenreReferenced) {
        IO.raiseError(new IllegalStateException("曲风已被引用，无法删除"))
      } else IO.unit

      // Step 4: Delete genre from GenreTable
      _ <- IO(logger.info(s"Deleting genreID ${genreID} from GenreTable."))
      deleteResult <- deleteGenreByID(genreID)
      _ <- IO(logger.info(s"Delete operation result: $deleteResult."))
    } yield "删除成功"
  }

  /**
   * Step 2.1: Check if genreID exists in GenreTable
   */
  private def checkGenreExistence(genreID: String)(using PlanContext): IO[Boolean] = {
    val sql = s"SELECT COUNT(1) FROM ${schemaName}.genre_table WHERE genre_id = ?"
    val parameters = List(SqlParameter("String", genreID))
    readDBInt(sql, parameters).map(_ > 0) // Return true if count > 0
  }

  /**
   * Step 3.1: Validate if the genreID is referenced in SongTable (genres field)
   */
  private def checkGenreUsage(genreID: String)(using PlanContext): IO[Boolean] = {
    val sql = s"SELECT COUNT(1) FROM ${schemaName}.song_table WHERE genres LIKE ?"
    val parameters = List(SqlParameter("String", s"""%"$genreID"%""")) // Genres are stored as a JSON array
    readDBInt(sql, parameters).map(_ > 0) // Return true if count > 0
  }

  /**
   * Step 4.1: Delete genre from GenreTable by genreID
   */
  private def deleteGenreByID(genreID: String)(using PlanContext): IO[String] = {
    val sql = s"DELETE FROM ${schemaName}.genre_table WHERE genre_id = ?"
    val parameters = List(SqlParameter("String", genreID))
    writeDB(sql, parameters)
  }
} 
========== End of src\main\scala\Impl\DeleteGenrePlanner.scala ========== 
 
========== src\main\scala\Impl\DeleteSongPlanner.scala ========== 
package Impl


import APIs.OrganizeService.ValidateAdminMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import org.slf4j.LoggerFactory
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import APIs.OrganizeService.ValidateAdminMapping
import io.circe._
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class DeleteSongPlanner(
                              songID: String,
                              adminID: String,
                              adminToken: String,
                              override val planContext: PlanContext
                            ) extends Planner[String] {

  val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using planContext: PlanContext): IO[String] = {
    for {
      // Step 1: 验证管理员身份
      _ <- IO(logger.info(s"验证管理员身份，adminID: ${adminID}, adminToken: ${adminToken}"))
      isAdminValid <- ValidateAdminMapping(adminID, adminToken).send
      _ <- IO(logger.info(s"管理员验证结果: ${isAdminValid}"))
      _ <- if (!isAdminValid) IO.raiseError(new Exception("管理员认证失败")) else IO.unit

      // Step 2: 检查 songID 是否存在
      _ <- IO(logger.info(s"检查歌曲是否存在，songID: ${songID}"))
      songExists <- checkSongExists(songID)
      _ <- if (!songExists) IO.raiseError(new Exception("歌曲不存在")) else IO.unit

      // Step 3: 检查引用情况
      _ <- IO(logger.info(s"检查歌曲是否被引用, songID: ${songID}"))
      isReferenced <- checkSongReferenced(songID)
      _ <- if (isReferenced) IO.raiseError(new Exception("歌曲被引用，无法删除")) else IO.unit

      // Step 4: 删除歌曲记录
      _ <- IO(logger.info(s"从SongTable删除歌曲记录, songID: ${songID}"))
      deleteResult <- deleteSong(songID)
      _ <- IO(logger.info(s"删除结果: ${deleteResult}"))
    } yield "删除成功"
  }

  // 检查歌曲是否存在
  private def checkSongExists(songID: String)(using PlanContext): IO[Boolean] = {
    val sql =
      s"""
SELECT COUNT(1)
FROM ${schemaName}.song_table
WHERE song_id = ?;
""".stripMargin
    readDBInt(sql, List(SqlParameter("String", songID))).map(_ > 0)
  }

  // 检查歌曲是否被引用
  private def checkSongReferenced(songID: String)(using PlanContext): IO[Boolean] = {
    for {
      // 检查专辑(Album)是否引用歌曲
      _ <- IO(logger.info(s"检查专辑引用，songID: ${songID}"))
      albumReferenceCount <- readDBInt(
        s"SELECT COUNT(1) FROM ${schemaName}.album WHERE song_ids @> ?;",
        List(SqlParameter("Array[String]", List(songID).asJson.noSpaces))
      )

      // 检查收藏(收藏夹/Collection)是否引用歌曲
      _ <- IO(logger.info(s"检查歌单引用，songID: ${songID}"))
      collectionReferenceCount <- readDBInt(
        s"SELECT COUNT(1) FROM ${schemaName}.collection WHERE song_ids @> ?;",
        List(SqlParameter("Array[String]", List(songID).asJson.noSpaces))
      )

      // 检查播放列表(Playlist)是否引用歌曲
      _ <- IO(logger.info(s"检查播放集引用，songID: ${songID}"))
      playlistReferenceCount <- readDBInt(
        s"SELECT COUNT(1) FROM ${schemaName}.playlist WHERE song_ids @> ?;",
        List(SqlParameter("Array[String]", List(songID).asJson.noSpaces))
      )
      _ <- IO(logger.info(s"引用统计: 专辑=${albumReferenceCount}, 歌单=${collectionReferenceCount}, 播放列表=${playlistReferenceCount}"))
    } yield albumReferenceCount > 0 || collectionReferenceCount > 0 || playlistReferenceCount > 0
  }

  // 删除歌曲
  private def deleteSong(songID: String)(using PlanContext): IO[String] = {
    val sql =
      s"""
DELETE FROM ${schemaName}.song_table
WHERE song_id = ?;
""".stripMargin
    writeDB(sql, List(SqlParameter("String", songID)))
  }
} 
========== End of src\main\scala\Impl\DeleteSongPlanner.scala ========== 
 
========== src\main\scala\Impl\FilterSongsByEntityPlanner.scala ========== 
package Impl


import Objects.CreatorService.Band
import Objects.CreatorService.Artist
import APIs.OrganizeService.ValidateUserMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import org.slf4j.LoggerFactory
import io.circe.Json
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import APIs.OrganizeService.ValidateUserMapping
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class FilterSongsByEntityPlanner(
                                       entityID: Option[String],
                                       entityType: Option[String],
                                       genres: List[String],
                                       userID: String,
                                       userToken: String,
                                       override val planContext: PlanContext
                                     ) extends Planner[List[String]] {
  val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using planContext: PlanContext): IO[List[String]] = {
    for {
      // Step 1: Validate userToken and userID mapping
      _ <- IO(logger.info("Validating userToken and userID mapping"))
      isValid <- ValidateUserMapping(userID, userToken).send
      _ <- if (!isValid) IO.raiseError(new IllegalArgumentException("Invalid userToken or userID mapping")) else IO.unit

      // Step 2: Validate entityID if applicable
      _ <- IO(logger.info(s"Validating entityID for entityType: ${entityType}, entityID: ${entityID}"))
      _ <- validateEntityID

      // Step 3: Build filtering criteria for songs
      _ <- IO(logger.info("Building filter criteria for songs"))
      queryResult <- filterSongs

    } yield queryResult
  }

  private def validateEntityID(using PlanContext): IO[Unit] = {
    entityType match {
      case Some("artist") =>
        entityID match {
          case Some(id) => validateArtistID(id)
          case None => IO.unit // No entityID provided for validation
        }
      case Some("band") =>
        entityID match {
          case Some(id) => validateBandID(id)
          case None => IO.unit // No entityID provided for validation
        }
      case None => IO.unit // No entityType provided, skip validation
      case Some(_) => IO.raiseError(new IllegalArgumentException("Invalid entityType"))
    }
  }

  private def validateArtistID(artistID: String)(using PlanContext): IO[Unit] = {
    val sql = s"SELECT 1 FROM ${schemaName}.artist WHERE artist_id = ? LIMIT 1"
    readDBJsonOptional(sql, List(SqlParameter("String", artistID))).flatMap {
      case Some(_) => IO.unit
      case None => IO.raiseError(new IllegalArgumentException(s"Invalid artistID: ${artistID}"))
    }
  }

  private def validateBandID(bandID: String)(using PlanContext): IO[Unit] = {
    val sql = s"SELECT 1 FROM ${schemaName}.band WHERE band_id = ? LIMIT 1"
    readDBJsonOptional(sql, List(SqlParameter("String", bandID))).flatMap {
      case Some(_) => IO.unit
      case None => IO.raiseError(new IllegalArgumentException(s"Invalid bandID: ${bandID}"))
    }
  }

  private def filterSongs(using PlanContext): IO[List[String]] = {
    val sqlBuilder = new StringBuilder(s"SELECT song_id FROM ${schemaName}.song_table WHERE 1=1")
    val parameters = scala.collection.mutable.ListBuffer.empty[SqlParameter]

    // Add filter for entityType and entityID
    entityType match {
      case Some("artist") =>
        entityID.foreach { id =>
          sqlBuilder.append(" AND (creators @> ?::jsonb OR performers @> ?::jsonb)")
          parameters += SqlParameter("String", s"""["${id}"]""")
          parameters += SqlParameter("String", s"""["${id}"]""")
        }
      case Some("band") =>
        entityID.foreach { id =>
          sqlBuilder.append(" AND (creators @> ?::jsonb OR performers @> ?::jsonb)")
          parameters += SqlParameter("String", s"""["${id}"]""")
          parameters += SqlParameter("String", s"""["${id}"]""")
        }
      case _ => // Do nothing if entityType is None or invalid
    }

    // Add filter for genres
    if (genres.nonEmpty) {
      sqlBuilder.append(" AND genres && ?::jsonb")
      parameters += SqlParameter("String", genres.asJson.noSpaces)
    }

    val sql = sqlBuilder.toString()
    logger.info(s"Executing SQL query: ${sql} with parameters: ${parameters.mkString(", ")}")

    readDBRows(sql, parameters.toList).map { rows =>
      rows.map(json => decodeField[String](json, "song_id"))
    }
  }
} 
========== End of src\main\scala\Impl\FilterSongsByEntityPlanner.scala ========== 
 
========== src\main\scala\Impl\SearchSongsByNamePlanner.scala ========== 
package Impl


import APIs.OrganizeService.ValidateUserMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import io.circe.Json
import org.slf4j.LoggerFactory
import cats.implicits._
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import org.joda.time.DateTime
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import APIs.OrganizeService.ValidateUserMapping
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class SearchSongsByNamePlanner(
                                     keywords: String,
                                     userID: String,
                                     userToken: String,
                                     override val planContext: PlanContext
                                   ) extends Planner[List[String]] {

  private val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using planContext: PlanContext): IO[List[String]] = {
    for {
      // Step 1: Validate user rights
      _ <- IO(logger.info(s"[Step 1] Validate user rights for userID=${userID}, userToken=${userToken}"))
      isValid <- ValidateUserMapping(userID, userToken).send
      _ <- IO {
        if (!isValid) logger.error(s"[Step 1.1] User validation failed for userID=${userID}, userToken=${userToken}")
        else logger.info("[Step 1.1] User validation succeeded")
      }
      _ <- if (!isValid) IO.raiseError(new IllegalAccessException("User authentication invalid")) else IO.unit

      // Step 2: Check if keywords are empty
      _ <- IO(logger.info(s"[Step 2] Check if keywords are empty: ${keywords}"))
      result <- if (keywords.isEmpty)
        IO {
          logger.info("[Step 2.1] Keywords are empty. Returning an empty song list.")
          List.empty[String]
        }
      else
        performSearch(keywords)
    } yield result
  }

  /**
   * Database search operation: Fuzzy search song names by keywords.
   */
  private def performSearch(keywords: String)(using PlanContext): IO[List[String]] = {
    val sql =
      s"""
         |SELECT song_id
         |FROM ${schemaName}.song_table
         |WHERE name ILIKE ?;
       """.stripMargin

    val parameters = List(SqlParameter("String", s"%${keywords}%"))
    logger.info(s"[Step 3] Starting song search with keywords='${keywords}', SQL='${sql}', parameters='${parameters.map(_.value).mkString(", ")}'")

    readDBRows(sql, parameters).flatMap { rows =>
      IO {
        logger.info(s"[Step 3.1] Query result count=${rows.length}")
        rows.map(json => decodeField[String](json, "song_id"))
      }
    }
  }
} 
========== End of src\main\scala\Impl\SearchSongsByNamePlanner.scala ========== 
 
========== src\main\scala\Impl\UpdateSongMetadataPlanner.scala ========== 
package Impl


import Objects.CreatorService.{Artist, Band}
import Objects.MusicService.Genre
import APIs.MusicService.ValidateSongOwnership
import Objects.CreatorService.Artist
import APIs.OrganizeService.ValidateUserMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import io.circe.Json
import org.joda.time.DateTime
import cats.effect.IO
import org.slf4j.LoggerFactory
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import cats.implicits._
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import Objects.CreatorService.Band
import APIs.OrganizeService.ValidateUserMapping
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class UpdateSongMetadataPlanner(
    songID: String,
    userID: String,
    userToken: String,
    name: Option[String],
    releaseTime: Option[DateTime],
    creators: List[String],
    performers: List[String],
    lyricists: List[String],
    composers: List[String],
    arrangers: List[String],
    instrumentalists: List[String],
    genres: List[String],
    override val planContext: PlanContext
) extends Planner[String] {

  val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using planContext: PlanContext): IO[String] = {
    for {
      // Step 1: Validate userToken and userID
      _ <- IO(logger.info("Validating userToken and userID..."))
      isValidToken <- ValidateUserMapping(userID, userToken).send
      _ <- if (!isValidToken) IO.raiseError(new Exception("Invalid user token")) else IO.unit

      // Step 2: Validate song ownership
      _ <- IO(logger.info(s"Validating song ownership for userID=${userID}, songID=${songID}"))
      isOwner <- ValidateSongOwnership(songID, userID, userToken).send
      _ <- if (!isOwner) IO.raiseError(new Exception("User does not own this song")) else IO.unit

      // Step 3: Check if the song exists in the SongTable
      _ <- IO(logger.info(s"Checking if songID=${songID} exists in SongTable..."))
      songExists <- checkSongExists
      _ <- if (!songExists) IO.raiseError(new Exception("歌曲不存在")) else IO.unit

      // Step 4: Update the metadata
      _ <- IO(logger.info(s"Updating metadata for songID=${songID}..."))
      _ <- updateSongMetadata

      // Step 5: Validate updated data (if necessary)
      _ <- IO(logger.info(s"Validating updated song data for songID=${songID}..."))
      _ <- validateUpdatedData
    } yield "更新成功"
  }

  private def checkSongExists(using PlanContext): IO[Boolean] = {
    readDBJsonOptional(
      s"SELECT 1 FROM ${schemaName}.song_table WHERE song_id = ?;",
      List(SqlParameter("String", songID))
    ).map(_.isDefined)
  }

  private def updateSongMetadata(using PlanContext): IO[Unit] = {
    val updateFutures = List(
      name.map(updateName),
      releaseTime.map(updateReleaseTime),
      Some(updateIDListField("creators", creators)),
      Some(updateIDListField("performers", performers)),
      Some(updateIDListField("lyricists", lyricists)),
      Some(updateIDListField("composers", composers)),
      Some(updateIDListField("arrangers", arrangers)),
      Some(updateIDListField("instrumentalists", instrumentalists)),
      Some(updateGenres(genres))
    ).flatten
    updateFutures.sequence_.void
  }

  private def updateName(newName: String)(using PlanContext): IO[Unit] = {
    IO(logger.info(s"Updating name to ${newName} for songID=${songID}...")) >>
      writeDB(
        s"UPDATE ${schemaName}.song_table SET name = ? WHERE song_id = ?;",
        List(SqlParameter("String", newName), SqlParameter("String", songID))
      ).void
  }

  private def updateReleaseTime(newTime: DateTime)(using PlanContext): IO[Unit] = {
    IO(logger.info(s"Updating releaseTime to ${newTime} for songID=${songID}...")) >>
      writeDB(
        s"UPDATE ${schemaName}.song_table SET release_time = ? WHERE song_id = ?;",
        List(SqlParameter("DateTime", newTime.getMillis.toString), SqlParameter("String", songID))
      ).void
  }

  private def updateIDListField(fieldName: String, ids: List[String])(using PlanContext): IO[Unit] = {
    IO(logger.info(s"Updating field ${fieldName} for songID=${songID} with IDs: ${ids}...")) >>
      validateIDsExist(ids) >>
      writeDB(
        s"UPDATE ${schemaName}.song_table SET ${fieldName} = ? WHERE song_id = ?;",
        List(SqlParameter("Array[String]", ids.asJson.noSpaces), SqlParameter("String", songID))
      ).void
  }

  private def updateGenres(genres: List[String])(using PlanContext): IO[Unit] = {
    IO(logger.info(s"Updating genres for songID=${songID} with genres: ${genres}...")) >>
      validateGenresExist(genres) >>
      writeDB(
        s"UPDATE ${schemaName}.song_table SET genres = ? WHERE song_id = ?;",
        List(SqlParameter("Array[String]", genres.asJson.noSpaces), SqlParameter("String", songID))
      ).void
  }

  private def validateIDsExist(ids: List[String])(using PlanContext): IO[Unit] = {
    ids.map { id =>
      val artistCheck = readDBJsonOptional(
        s"SELECT 1 FROM ${schemaName}.artist WHERE artist_id = ?;",
        List(SqlParameter("String", id))
      )
      val bandCheck = readDBJsonOptional(
        s"SELECT 1 FROM ${schemaName}.band WHERE band_id = ?;",
        List(SqlParameter("String", id))
      )
      for {
        artistExists <- artistCheck
        bandExists <- bandCheck
        _ <- if (artistExists.isEmpty && bandExists.isEmpty)
          IO.raiseError(new Exception(s"ID ${id} not found in Artist or Band"))
        else IO.unit
      } yield ()
    }.sequence_.void
  }

  private def validateGenresExist(genres: List[String])(using PlanContext): IO[Unit] = {
    genres.map { genreID =>
      readDBJsonOptional(
        s"SELECT 1 FROM ${schemaName}.genre WHERE genre_id = ?;",
        List(SqlParameter("String", genreID))
      ).flatMap {
        case Some(_) => IO.unit
        case None    => IO.raiseError(new Exception(s"Genre with ID ${genreID} does not exist"))
      }
    }.sequence_.void
  }

  private def validateUpdatedData(using PlanContext): IO[Unit] = {
    IO(logger.info(s"Running integrity checks for songID=${songID}...")) >>
      IO.unit // Add actual integrity checks here if necessary
  }
} 
========== End of src\main\scala\Impl\UpdateSongMetadataPlanner.scala ========== 
 
========== src\main\scala\Impl\UploadNewSongPlanner.scala ========== 
package Impl


import Objects.CreatorService.Band
import Objects.CreatorService.Artist
import APIs.OrganizeService.ValidateUserMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import org.slf4j.LoggerFactory
import org.joda.time.DateTime
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import APIs.OrganizeService.ValidateUserMapping
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class UploadNewSongMessage(
  userID: String,
  userToken: String,
  name: String,
  releaseTime: DateTime,
  creators: List[String],
  performers: List[String],
  lyricists: List[String],
  arrangers: List[String],
  instrumentalists: List[String],
  genres: List[String],
  composers: List[String]
) extends API[String]("UploadNewSong")

case class UploadNewSongPlanner(
  uploadNewSongMessage: UploadNewSongMessage,
  override val planContext: PlanContext
) extends Planner[String] {
  val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using PlanContext): IO[String] = {
    val message = uploadNewSongMessage

    for {
      // Step 1: Validate user token and ID association
      _ <- IO(logger.info(s"验证用户令牌与用户ID的关联关系：userID=${message.userID}, userToken=${message.userToken}"))
      isValidUser <- ValidateUserMapping(message.userID, message.userToken).send
      _ <- if (!isValidUser) IO.raiseError(new IllegalArgumentException("Invalid userToken or userID association.")) else IO.unit

      // Step 2: Validate song name is not empty
      _ <- IO(logger.info(s"验证歌曲名称是否为空：name=${message.name}"))
      _ <- if (message.name.isEmpty) IO.raiseError(new IllegalArgumentException("Song name cannot be empty.")) else IO.unit

      // Step 3: Validate creators and performers exist in Artist or Band
      _ <- IO(logger.info("验证creators和performers字段中的每个ID是否存在于Artist或Band"))
      _ <- validateArtistsOrBands("creator", message.creators)
      _ <- validateArtistsOrBands("performer", message.performers)

      // Step 4: Validate genres exist in GenreTable
      _ <- IO(logger.info("验证genres字段中的每个曲风ID是否存在"))
      _ <- validateGenres(message.genres)

      // Step 5: Validate optional fields
      _ <- IO(logger.info("验证所有可选字段的格式和存在性"))
      _ <- validateArtistsOrBands("lyricist", message.lyricists)
      _ <- validateArtistsOrBands("composer", message.composers)
      _ <- validateArtistsOrBands("arranger", message.arrangers)
      _ <- validateArtistsOrBands("instrumentalist", message.instrumentalists)

      // Step 6: Generate unique songID
      _ <- IO(logger.info("生成唯一的songID标识符"))
      songID <- IO(java.util.UUID.randomUUID().toString)

      // Step 7: Insert new song into SongTable
      _ <- IO(logger.info(s"将新歌曲信息存入SongTable，songID=${songID}"))
      _ <- insertSongIntoDB(message, songID)

      // Step 8: Return songID
      _ <- IO(logger.info(s"新歌曲上传成功，songID=${songID}"))
    } yield songID
  }

  private def validateArtistsOrBands(fieldName: String, ids: List[String])(using PlanContext): IO[Unit] = {
    ids.traverse_ { id =>
      for {
        bandExists <- readDBJsonOptional(
          s"SELECT * FROM ${schemaName}.band WHERE band_id = ?",
          List(SqlParameter("String", id))
        ).map(_.isDefined)
        artistExists <- readDBJsonOptional(
          s"SELECT * FROM ${schemaName}.artist WHERE artist_id = ?",
          List(SqlParameter("String", id))
        ).map(_.isDefined)
        _ <- if (!bandExists && !artistExists)
          IO.raiseError(new IllegalArgumentException(s"Invalid $fieldName ID: $id not found in Artist or Band."))
        else IO.unit
      } yield ()
    }
  }

  private def validateGenres(genreIDs: List[String])(using PlanContext): IO[Unit] = {
    genreIDs.traverse_ { genreID =>
      for {
        genreExists <- readDBJsonOptional(
          s"SELECT * FROM ${schemaName}.genre_table WHERE genre_id = ?",
          List(SqlParameter("String", genreID))
        ).map(_.isDefined)
        _ <- if (!genreExists)
          IO.raiseError(new IllegalArgumentException(s"Invalid genre ID: $genreID not found in GenreTable."))
        else IO.unit
      } yield ()
    }
  }

  private def insertSongIntoDB(message: UploadNewSongMessage, songID: String)(using PlanContext): IO[Unit] = {
    val params = List(
      SqlParameter("String", songID),
      SqlParameter("String", message.name),
      SqlParameter("DateTime", message.releaseTime.getMillis.toString),
      SqlParameter("String", message.creators.asJson.noSpaces),
      SqlParameter("String", message.performers.asJson.noSpaces),
      SqlParameter("String", message.lyricists.asJson.noSpaces),
      SqlParameter("String", message.composers.asJson.noSpaces),
      SqlParameter("String", message.arrangers.asJson.noSpaces),
      SqlParameter("String", message.instrumentalists.asJson.noSpaces),
      SqlParameter("String", message.genres.asJson.noSpaces),
      SqlParameter("String", message.userID)
    )

    writeDB(
      s"""
        INSERT INTO ${schemaName}.song_table
        (song_id, name, release_time, creators, performers, lyricists, composers, arrangers, instrumentalists, genres, uploader_id)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      """,
      params
    ).void
  }
} 
========== End of src\main\scala\Impl\UploadNewSongPlanner.scala ========== 
 
========== src\main\scala\Impl\ValidateSongOwnershipPlanner.scala ========== 
package Impl


import Objects.CreatorService.Band
import Objects.CreatorService.Artist
import APIs.OrganizeService.ValidateAdminMapping
import APIs.OrganizeService.ValidateUserMapping
import Common.API.{PlanContext, Planner}
import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import io.circe._
import io.circe.generic.auto._
import org.slf4j.LoggerFactory
import cats.implicits.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime, encodeDateTime}
import io.circe._
import io.circe.syntax._
import io.circe.generic.auto._
import org.joda.time.DateTime
import cats.implicits.*
import Common.DBAPI._
import Common.API.{PlanContext, Planner}
import cats.effect.IO
import Common.Object.SqlParameter
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}
import Common.ServiceUtils.schemaName
import APIs.OrganizeService.ValidateUserMapping
import io.circe.syntax._
import org.joda.time.DateTime
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

case class ValidateSongOwnershipPlanner(
                                         songID: String,
                                         userID: String,
                                         userToken: String,
                                         override val planContext: PlanContext
                                       ) extends Planner[Boolean] {

  val logger = LoggerFactory.getLogger(this.getClass.getSimpleName + "_" + planContext.traceID.id)

  override def plan(using PlanContext): IO[Boolean] = {
    for {
      // Step 1: Validate user token
      isUserValid <- ValidateUserMapping(userID, userToken).send
      _ <- IO(logger.info(s"用户令牌验证结果: ${isUserValid}"))
      _ <- if (!isUserValid) IO.raiseError(new IllegalArgumentException("Invalid user or token")) else IO.unit
      
      // Step 2: Check if the user is the uploader
      isUploader <- isUserUploader()
      _ <- IO(logger.info(s"是否为上传者: ${isUploader}"))

      // Step 3: Check if the user is creator or manager
      isCreatorManager <- if (!isUploader) isUserCreatorOrManager() else IO.pure(false)
      _ <- IO(logger.info(s"是否为创作者或管理者: ${isCreatorManager}"))

      // Step 4: Check if the user is an admin
      isAdmin <- if (!isUploader && !isCreatorManager) checkAdminPrivileges() else IO.pure(false)
      _ <- IO(logger.info(s"是否为管理员: ${isAdmin}"))

      // Step 5: Combine results
      isOwner = isUploader || isCreatorManager || isAdmin
      _ <- IO(logger.info(s"最终权限验证结果 isOwner = ${isOwner}"))
    } yield isOwner
  }

  private def isUserUploader()(using PlanContext): IO[Boolean] = {
    for {
      _ <- IO(logger.info(s"开始验证是否为歌曲上传者"))
      songDataOpt <- readDBJsonOptional(
        s"SELECT uploader_id FROM ${schemaName}.song_table WHERE song_id = ?",
        List(SqlParameter("String", songID))
      )
      uploaderID <- IO { songDataOpt.map(json => decodeField[String](json, "uploader_id")) }
      isUploader = uploaderID.contains(userID)
    } yield isUploader
  }

  private def isUserCreatorOrManager()(using PlanContext): IO[Boolean] = {
    for {
      _ <- IO(logger.info(s"开始验证是否为创作者或管理者"))
      songDataOpt <- readDBJsonOptional(
        s"SELECT creators FROM ${schemaName}.song_table WHERE song_id = ?",
        List(SqlParameter("String", songID))
      )
      creatorsList <- IO {
        songDataOpt.map(json => decodeField[List[String]](json, "creators")).getOrElse(List())
      }
      _ <- IO(logger.info(s"歌曲创作者列表: ${creatorsList}"))

      isManagedByUser <- creatorsList.existsM(isManagedByUserID)
      _ <- IO(logger.info(s"是否存在创作者/乐队受用户 ${userID} 管理: ${isManagedByUser}"))
    } yield isManagedByUser
  }

  private def isManagedByUserID(creatorID: String)(using PlanContext): IO[Boolean] = {
    for {
      artistOpt <- readDBJsonOptional(
        s"SELECT managed_by FROM ${schemaName}.artist WHERE artist_id = ?",
        List(SqlParameter("String", creatorID))
      )
      bandOpt <- readDBJsonOptional(
        s"SELECT managed_by FROM ${schemaName}.band WHERE band_id = ?",
        List(SqlParameter("String", creatorID))
      )
      artistManagers <- IO {
        artistOpt.map(json => decodeField[List[String]](json, "managed_by")).getOrElse(List())
      }
      bandManagers <- IO {
        bandOpt.map(json => decodeField[List[String]](json, "managed_by")).getOrElse(List())
      }

      isManaged = artistManagers.contains(userID) || bandManagers.contains(userID)
    } yield isManaged
  }

  private def checkAdminPrivileges()(using PlanContext): IO[Boolean] = {
    ValidateAdminMapping(userID, userToken).send
  }
} 
========== End of src\main\scala\Impl\ValidateSongOwnershipPlanner.scala ========== 
 
========== src\main\scala\Objects\CreatorService\Artist.scala ========== 
package Objects.CreatorService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * Artist
 * desc: 艺术家信息
 * @param artistID: String (艺术家的唯一ID)
 * @param name: String (艺术家的名字)
 * @param bio: String (艺术家的简介)
 * @param managedBy: String (管理艺术家的用户ID的列表)
 */

case class Artist(
  artistID: String,
  name: String,
  bio: String,
  managedBy: List[String]
){

  //process class code 预留标志位，不要删除


}


case object Artist{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[Artist] = deriveEncoder
  private val circeDecoder: Decoder[Artist] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[Artist] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[Artist] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[Artist]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given artistEncoder: Encoder[Artist] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given artistDecoder: Decoder[Artist] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\CreatorService\Artist.scala ========== 
 
========== src\main\scala\Objects\CreatorService\Band.scala ========== 
package Objects.CreatorService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * Band
 * desc: 表示一个音乐组合的信息
 * @param bandID: String (乐队的唯一标识)
 * @param name: String (乐队名称)
 * @param members: String (乐队成员的ID列表)
 * @param bio: String (乐队的简介)
 * @param managedBy: String (负责管理该乐队的管理者ID列表)
 */

case class Band(
  bandID: String,
  name: String,
  members: List[String],
  bio: String,
  managedBy: List[String]
){

  //process class code 预留标志位，不要删除


}


case object Band{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[Band] = deriveEncoder
  private val circeDecoder: Decoder[Band] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[Band] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[Band] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[Band]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given bandEncoder: Encoder[Band] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given bandDecoder: Decoder[Band] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\CreatorService\Band.scala ========== 
 
========== src\main\scala\Objects\MusicService\Genre.scala ========== 
package Objects.MusicService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * Genre
 * desc: 音乐流派信息，包括ID、名称以及描述
 * @param genreID: String (流派的唯一标识符)
 * @param name: String (流派的名称)
 * @param description: String (流派的描述与相关信息)
 */

case class Genre(
  genreID: String,
  name: String,
  description: String
){

  //process class code 预留标志位，不要删除


}


case object Genre{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[Genre] = deriveEncoder
  private val circeDecoder: Decoder[Genre] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[Genre] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[Genre] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[Genre]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given genreEncoder: Encoder[Genre] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given genreDecoder: Decoder[Genre] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\MusicService\Genre.scala ========== 
 
========== src\main\scala\Objects\MusicService\Song.scala ========== 
package Objects.MusicService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * Song
 * desc: 歌曲信息，包括ID、名称、发布时间、创作者、表演者和所属分类
 * @param songID: String (歌曲的唯一ID)
 * @param name: String (歌曲名称)
 * @param releaseTime: DateTime (歌曲的发布时间)
 * @param creators: String (歌曲的创作者)
 * @param performers: String (歌曲的表演者)
 * @param genres: String (歌曲所属的分类)
 */

case class Song(
  songID: String,
  name: String,
  releaseTime: DateTime,
  creators: List[String],
  performers: List[String],
  genres: List[String]
){

  //process class code 预留标志位，不要删除


}


case object Song{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[Song] = deriveEncoder
  private val circeDecoder: Decoder[Song] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[Song] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[Song] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[Song]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given songEncoder: Encoder[Song] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given songDecoder: Decoder[Song] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\MusicService\Song.scala ========== 
 
========== src\main\scala\Objects\OrganizeService\RequestStatus.scala ========== 
package Objects.OrganizeService

import com.fasterxml.jackson.databind.annotation.{JsonDeserialize, JsonSerialize}
import com.fasterxml.jackson.core.{JsonGenerator, JsonParser}
import com.fasterxml.jackson.databind.{DeserializationContext, JsonDeserializer, JsonSerializer, SerializerProvider}
import io.circe.{Decoder, Encoder}

@JsonSerialize(`using` = classOf[RequestStatusSerializer])
@JsonDeserialize(`using` = classOf[RequestStatusDeserializer])
enum RequestStatus(val desc: String):

  override def toString: String = this.desc

  case Pending extends RequestStatus("待处理") // 待处理
  case Approved extends RequestStatus("审核通过") // 审核通过
  case Rejected extends RequestStatus("审核拒绝") // 审核拒绝


object RequestStatus:
  given encode: Encoder[RequestStatus] = Encoder.encodeString.contramap[RequestStatus](toString)

  given decode: Decoder[RequestStatus] = Decoder.decodeString.emap(fromStringEither)

  def fromString(s: String):RequestStatus  = s match
    case "待处理" => Pending
    case "审核通过" => Approved
    case "审核拒绝" => Rejected
    case _ => throw Exception(s"Unknown RequestStatus: $s")

  def fromStringEither(s: String):Either[String, RequestStatus]  = s match
    case "待处理" => Right(Pending)
    case "审核通过" => Right(Approved)
    case "审核拒绝" => Right(Rejected)
    case _ => Left(s"Unknown RequestStatus: $s")

  def toString(t: RequestStatus): String = t match
    case Pending => "待处理"
    case Approved => "审核通过"
    case Rejected => "审核拒绝"


// Jackson 序列化器
class RequestStatusSerializer extends JsonSerializer[RequestStatus] {
  override def serialize(value: RequestStatus, gen: JsonGenerator, serializers: SerializerProvider): Unit = {
    gen.writeString(RequestStatus.toString(value)) // 直接写出字符串
  }
}

// Jackson 反序列化器
class RequestStatusDeserializer extends JsonDeserializer[RequestStatus] {
  override def deserialize(p: JsonParser, ctxt: DeserializationContext): RequestStatus = {
    RequestStatus.fromString(p.getText)
  }
}

 
========== End of src\main\scala\Objects\OrganizeService\RequestStatus.scala ========== 
 
========== src\main\scala\Objects\OrganizeService\User.scala ========== 
package Objects.OrganizeService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * User
 * desc: 用户信息，包含用户的账号信息与密码
 * @param userID: String (用户的唯一标识)
 * @param account: String (用户登录账号)
 * @param password: String (用户登录密码)
 */

case class User(
  userID: String,
  account: String,
  password: String
){

  //process class code 预留标志位，不要删除


}


case object User{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[User] = deriveEncoder
  private val circeDecoder: Decoder[User] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[User] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[User] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[User]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given userEncoder: Encoder[User] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given userDecoder: Decoder[User] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\OrganizeService\User.scala ========== 
 
========== src\main\scala\Objects\TrackService\Album.scala ========== 
package Objects.TrackService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * Album
 * desc: 专辑信息
 * @param albumID: String (专辑的唯一标识)
 * @param name: String (专辑名称)
 * @param creators: String (专辑的创建者)
 * @param collaborators: String (专辑的协作者)
 * @param releaseTime: DateTime (专辑发布时间)
 * @param description: String (专辑的详细描述)
 * @param contents: String (专辑的内容列表)
 */

case class Album(
  albumID: String,
  name: String,
  creators: List[String],
  collaborators: List[String],
  releaseTime: DateTime,
  description: Option[String] = None,
  contents: List[String]
){

  //process class code 预留标志位，不要删除


}


case object Album{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[Album] = deriveEncoder
  private val circeDecoder: Decoder[Album] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[Album] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[Album] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[Album]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given albumEncoder: Encoder[Album] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given albumDecoder: Decoder[Album] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\TrackService\Album.scala ========== 
 
========== src\main\scala\Objects\TrackService\Collection.scala ========== 
package Objects.TrackService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID


/**
 * Collection
 * desc: 集合信息, 用于表示专辑集、歌单等，包含集合的基本信息
 * @param collectionID: String (集合的唯一ID)
 * @param name: String (集合的名字)
 * @param ownerID: String (集合创建者的唯一ID)
 * @param maintainers: String (集合维护者的用户ID列表)
 * @param uploadTime: DateTime (集合的上传时间)
 * @param description: String (集合的描述信息)
 * @param contents: String (集合中包含的内容ID列表)
 */

case class Collection(
  collectionID: String,
  name: String,
  ownerID: String,
  maintainers: List[String],
  uploadTime: DateTime,
  description: String,
  contents: List[String]
){

  //process class code 预留标志位，不要删除


}


case object Collection{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[Collection] = deriveEncoder
  private val circeDecoder: Decoder[Collection] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[Collection] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[Collection] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[Collection]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given collectionEncoder: Encoder[Collection] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given collectionDecoder: Decoder[Collection] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\TrackService\Collection.scala ========== 
 
========== src\main\scala\Objects\TrackService\Playlist.scala ========== 
package Objects.TrackService


import io.circe.{Decoder, Encoder, Json}
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.syntax.*
import io.circe.parser.*
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

import com.fasterxml.jackson.core.`type`.TypeReference
import Common.Serialize.JacksonSerializeUtils

import scala.util.Try

import org.joda.time.DateTime
import java.util.UUID
import Objects.TrackService.PlayMode

/**
 * Playlist
 * desc: 播放列表，包含当前播放的歌曲及播放模式等
 * @param playlistID: String (播放列表的唯一标识)
 * @param ownerID: String (播放列表所有者的唯一标识)
 * @param contents: String (播放列表包含的歌曲ID列表)
 * @param currentSongID: String (当前正在播放的歌曲ID)
 * @param currentPosition: Int (当前播放的具体位置（秒）)
 * @param playMode: PlayMode:1102 (当前播放模式)
 */

case class Playlist(
  playlistID: String,
  ownerID: String,
  contents: List[String],
  currentSongID: String,
  currentPosition: Int,
  playMode: PlayMode
){

  //process class code 预留标志位，不要删除


}


case object Playlist{

    
  import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

  // Circe 默认的 Encoder 和 Decoder
  private val circeEncoder: Encoder[Playlist] = deriveEncoder
  private val circeDecoder: Decoder[Playlist] = deriveDecoder

  // Jackson 对应的 Encoder 和 Decoder
  private val jacksonEncoder: Encoder[Playlist] = Encoder.instance { currentObj =>
    Json.fromString(JacksonSerializeUtils.serialize(currentObj))
  }

  private val jacksonDecoder: Decoder[Playlist] = Decoder.instance { cursor =>
    try { Right(JacksonSerializeUtils.deserialize(cursor.value.noSpaces, new TypeReference[Playlist]() {})) } 
    catch { case e: Throwable => Left(io.circe.DecodingFailure(e.getMessage, cursor.history)) }
  }
  
  // Circe + Jackson 兜底的 Encoder
  given playlistEncoder: Encoder[Playlist] = Encoder.instance { config =>
    Try(circeEncoder(config)).getOrElse(jacksonEncoder(config))
  }

  // Circe + Jackson 兜底的 Decoder
  given playlistDecoder: Decoder[Playlist] = Decoder.instance { cursor =>
    circeDecoder.tryDecode(cursor).orElse(jacksonDecoder.tryDecode(cursor))
  }



  //process object code 预留标志位，不要删除


}

 
========== End of src\main\scala\Objects\TrackService\Playlist.scala ========== 
 
========== src\main\scala\Objects\TrackService\PlayMode.scala ========== 
package Objects.TrackService

import com.fasterxml.jackson.databind.annotation.{JsonDeserialize, JsonSerialize}
import com.fasterxml.jackson.core.{JsonGenerator, JsonParser}
import com.fasterxml.jackson.databind.{DeserializationContext, JsonDeserializer, JsonSerializer, SerializerProvider}
import io.circe.{Decoder, Encoder}

@JsonSerialize(`using` = classOf[PlayModeSerializer])
@JsonDeserialize(`using` = classOf[PlayModeDeserializer])
enum PlayMode(val desc: String):

  override def toString: String = this.desc

  case Random extends PlayMode("随机播放") // 随机播放
  case LoopOne extends PlayMode("单曲循环") // 单曲循环
  case Next extends PlayMode("顺次播放") // 顺次播放
  case PauseAfterEnd extends PlayMode("播完暂停") // 播完暂停


object PlayMode:
  given encode: Encoder[PlayMode] = Encoder.encodeString.contramap[PlayMode](toString)

  given decode: Decoder[PlayMode] = Decoder.decodeString.emap(fromStringEither)

  def fromString(s: String):PlayMode  = s match
    case "随机播放" => Random
    case "单曲循环" => LoopOne
    case "顺次播放" => Next
    case "播完暂停" => PauseAfterEnd
    case _ => throw Exception(s"Unknown PlayMode: $s")

  def fromStringEither(s: String):Either[String, PlayMode]  = s match
    case "随机播放" => Right(Random)
    case "单曲循环" => Right(LoopOne)
    case "顺次播放" => Right(Next)
    case "播完暂停" => Right(PauseAfterEnd)
    case _ => Left(s"Unknown PlayMode: $s")

  def toString(t: PlayMode): String = t match
    case Random => "随机播放"
    case LoopOne => "单曲循环"
    case Next => "顺次播放"
    case PauseAfterEnd => "播完暂停"


// Jackson 序列化器
class PlayModeSerializer extends JsonSerializer[PlayMode] {
  override def serialize(value: PlayMode, gen: JsonGenerator, serializers: SerializerProvider): Unit = {
    gen.writeString(PlayMode.toString(value)) // 直接写出字符串
  }
}

// Jackson 反序列化器
class PlayModeDeserializer extends JsonDeserializer[PlayMode] {
  override def deserialize(p: JsonParser, ctxt: DeserializationContext): PlayMode = {
    PlayMode.fromString(p.getText)
  }
}

 
========== End of src\main\scala\Objects\TrackService\PlayMode.scala ========== 
 
========== src\main\scala\Process\Init.scala ========== 

package Process

import Common.API.{API, PlanContext, TraceID}
import Common.DBAPI.{initSchema, writeDB}
import Common.ServiceUtils.schemaName
import Global.ServerConfig
import cats.effect.IO
import io.circe.generic.auto.*
import java.util.UUID
import Global.DBConfig
import Process.ProcessUtils.server2DB
import Global.GlobalVariables

object Init {
  def init(config: ServerConfig): IO[Unit] = {
    given PlanContext = PlanContext(traceID = TraceID(UUID.randomUUID().toString), 0)
    given DBConfig = server2DB(config)

    val program: IO[Unit] = for {
      _ <- IO(GlobalVariables.isTest=config.isTest)
      _ <- API.init(config.maximumClientConnection)
      _ <- Common.DBAPI.SwitchDataSourceMessage(projectName = Global.ServiceCenter.projectName).send
      _ <- initSchema(schemaName)
            /** SongTable，记录歌曲的详细信息
       * song_id: 歌曲的唯一ID，主键
       * name: 歌曲名称
       * release_time: 歌曲的发布时间
       * creators: 创作者ID列表，存储为JSON格式
       * performers: 演唱者ID列表，存储为JSON格式
       * lyricists: 作词者ID列表，存储为JSON格式
       * composers: 作曲者ID列表，存储为JSON格式
       * arrangers: 编曲者ID列表，存储为JSON格式
       * instrumentalists: 演奏者ID列表，存储为JSON格式
       * genres: 曲风ID列表，存储为JSON格式
       * uploader_id: 上传者用户ID
       */
      _ <- writeDB(
        s"""
        CREATE TABLE IF NOT EXISTS "${schemaName}"."song_table" (
            song_id VARCHAR NOT NULL PRIMARY KEY,
            name TEXT NOT NULL,
            release_time TIMESTAMP NOT NULL,
            creators TEXT NOT NULL DEFAULT '[]',
            performers TEXT NOT NULL DEFAULT '[]',
            lyricists TEXT NOT NULL DEFAULT '[]',
            composers TEXT NOT NULL DEFAULT '[]',
            arrangers TEXT NOT NULL DEFAULT '[]',
            instrumentalists TEXT NOT NULL DEFAULT '[]',
            genres TEXT NOT NULL DEFAULT '[]',
            uploader_id TEXT NOT NULL
        );
         
        """,
        List()
      )
      /** 曲风表，包含曲风的基本信息
       * genre_id: 曲风的唯一ID
       * name: 曲风名称
       * description: 曲风简介
       */
      _ <- writeDB(
        s"""
        CREATE TABLE IF NOT EXISTS "${schemaName}"."genre_table" (
            genre_id VARCHAR NOT NULL PRIMARY KEY,
            name TEXT NOT NULL,
            description TEXT
        );
         
        """,
        List()
      )
    } yield ()

    program.handleErrorWith(err => IO {
      println("[Error] Process.Init.init 失败, 请检查 db-manager 是否启动及端口问题")
      err.printStackTrace()
    })
  }
}
     
========== End of src\main\scala\Process\Init.scala ========== 
 
========== src\main\scala\Process\ProcessUtils.scala ========== 
package Process

import Global.ServerConfig
import Global.DBConfig
import cats.effect.{IO, Resource}
import io.circe.generic.auto.*
import io.circe.parser.decode

import scala.io.{BufferedSource, Source}

object ProcessUtils {
  /** 读取config文件 */
  def readConfig(filePath: String): IO[ServerConfig] = {
    // Define a resource for managing the file
    val fileResource: Resource[IO, BufferedSource] = Resource.make {
      IO(Source.fromFile(filePath)) // Acquire the resource
    } { source =>
      IO(source.close()).handleErrorWith(e => IO{e.printStackTrace()}) // Release the resource, ignoring errors on close
    }

    // Use the resource
    fileResource.use { source =>
      IO {
        val fileContents = source.getLines().mkString
        decode[ServerConfig](fileContents) match {
          case Right(config) => config
          case Left(error) => throw new RuntimeException(s"Failed to decode config: $error")
        }
      }
    }
  }

  def server2DB(serviceConfig: ServerConfig): DBConfig = {
    DBConfig(
      jdbcUrl = serviceConfig.jdbcUrl,
      username = serviceConfig.username,
      password = serviceConfig.password,
      schemaName = Common.ServiceUtils.schemaName,
      prepStmtCacheSize = serviceConfig.prepStmtCacheSize,
      prepStmtCacheSqlLimit = serviceConfig.prepStmtCacheSqlLimit,
      maximumPoolSize = serviceConfig.maximumPoolSize,
      connectionLiveMinutes = serviceConfig.connectionLiveMinutes,
      maximumServerConnection = serviceConfig.maximumServerConnection
    )
  }
  
}

 
========== End of src\main\scala\Process\ProcessUtils.scala ========== 
 
========== src\main\scala\Process\Routes.scala ========== 

package Process

import Common.API.PlanContext
import Common.DBAPI.DidRollbackException
import cats.effect.*
import fs2.concurrent.Topic
import io.circe.*
import io.circe.derivation.Configuration
import io.circe.generic.auto.*
import io.circe.parser.decode
import io.circe.syntax.*
import org.http4s.*
import org.http4s.client.Client
import org.http4s.dsl.io.*
import scala.collection.concurrent.TrieMap
import Common.Serialize.CustomColumnTypes.*
import Impl.DeleteGenrePlanner
import Impl.SearchSongsByNamePlanner
import Impl.DeleteSongPlanner
import Impl.UpdateSongMetadataPlanner
import Impl.UploadNewSongPlanner
import Impl.FilterSongsByEntityPlanner
import Impl.CreateNewGenrePlanner
import Impl.ValidateSongOwnershipPlanner
import Common.API.TraceID
import org.joda.time.DateTime
import org.http4s.circe.*
import java.util.UUID
import Common.Serialize.CustomColumnTypes.{decodeDateTime,encodeDateTime}

object Routes:
  val projects: TrieMap[String, Topic[IO, String]] = TrieMap.empty

  private def executePlan(messageType: String, str: String): IO[String] =
    messageType match {
      case "DeleteGenre" =>
        IO(
          decode[DeleteGenrePlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for DeleteGenre[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       
      case "SearchSongsByName" =>
        IO(
          decode[SearchSongsByNamePlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for SearchSongsByName[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       
      case "DeleteSong" =>
        IO(
          decode[DeleteSongPlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for DeleteSong[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       
      case "UpdateSongMetadata" =>
        IO(
          decode[UpdateSongMetadataPlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for UpdateSongMetadata[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       
      case "UploadNewSong" =>
        IO(
          decode[UploadNewSongPlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for UploadNewSong[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       
      case "FilterSongsByEntity" =>
        IO(
          decode[FilterSongsByEntityPlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for FilterSongsByEntity[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       
      case "CreateNewGenre" =>
        IO(
          decode[CreateNewGenrePlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for CreateNewGenre[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       
      case "ValidateSongOwnership" =>
        IO(
          decode[ValidateSongOwnershipPlanner](str) match
            case Left(err) => err.printStackTrace(); throw new Exception(s"Invalid JSON for ValidateSongOwnership[${err.getMessage}]")
            case Right(value) => value.fullPlan.map(_.asJson.toString)
        ).flatten
       

      case "test" =>
        for {
          output  <- Utils.Test.test(str)(using  PlanContext(TraceID(""), 0))
        } yield output
      case _ =>
        IO.raiseError(new Exception(s"Unknown type: $messageType"))
    }

  def handlePostRequest(req: Request[IO]): IO[String] = {
    req.as[Json].map {
      bodyJson => {
        val planContext = PlanContext(TraceID(UUID.randomUUID().toString), transactionLevel = 0)
        val planContextJson = planContext.asJson
        val updatedJson = bodyJson.deepMerge(Json.obj("planContext" -> planContextJson))
        updatedJson.toString
      }
    }
  }
  val service: HttpRoutes[IO] = HttpRoutes.of[IO] {
    case GET -> Root / "health" =>
      Ok("OK")
      
    case GET -> Root / "stream" / projectName =>
      projects.get(projectName) match {
        case Some(topic) =>
          val stream = topic.subscribe(10)
          Ok(stream)
        case None =>
          Topic[IO, String].flatMap { topic =>
            projects.putIfAbsent(projectName, topic) match {
              case None =>
                val stream = topic.subscribe(10)
                Ok(stream)
              case Some(existingTopic) =>
                val stream = existingTopic.subscribe(10)
                Ok(stream)
            }
          }
      }
    case req@POST -> Root / "api" / name =>
      handlePostRequest(req).flatMap {
        executePlan(name, _)
      }.flatMap(Ok(_))
      .handleErrorWith {
        case e: DidRollbackException =>
          println(s"Rollback error: $e")
          val headers = Headers("X-DidRollback" -> "true")
          BadRequest(e.getMessage.asJson.toString).map(_.withHeaders(headers))

        case e: Throwable =>
          println(s"General error: $e")
          BadRequest(e.getMessage.asJson.toString)
      }
  }
   
========== End of src\main\scala\Process\Routes.scala ========== 
 
========== src\main\scala\Process\Server.scala ========== 
package Process

import Process.Routes.service
import cats.effect.*
import com.comcast.ip4s.*
import org.http4s.*
import org.http4s.ember.server.*
import org.http4s.implicits.*
import org.http4s.server.middleware.CORS
import org.typelevel.log4cats.Logger
import org.typelevel.log4cats.slf4j.{Slf4jFactory, Slf4jLogger}

import java.nio.channels.ClosedChannelException
import scala.concurrent.duration.*


object Server extends IOApp:
  given logger: Logger[IO] = Slf4jLogger.getLogger[IO]

  given Slf4jFactory[IO] = Slf4jFactory.create[IO]

  def httpApp: HttpApp[IO] = service.orNotFound

  override protected def reportFailure(err: Throwable): IO[Unit] =
    err match {
      case e: ClosedChannelException =>
        IO.unit
      case _ =>
        super.reportFailure(err)
    }

  def run(args: List[String]): IO[ExitCode] =
    ProcessUtils.readConfig(args.headOption.getOrElse("server_config.json"))
      .flatMap { config =>
        (for {
          _ <- Resource.eval(Init.init(config))
          app <- Resource.eval(CORS.policy.withAllowOriginAll(httpApp))

          server <- EmberServerBuilder.default[IO]
            .withHost(Host.fromString(config.serverIP).getOrElse(
              throw new IllegalArgumentException(s"Invalid IPv4 address: ${config.serverIP}")
            ))
            .withPort(Port.fromInt(config.serverPort).getOrElse(
              throw new IllegalArgumentException(s"Invalid port: ${config.serverPort}")
            ))
            .withIdleTimeout(30.minutes)
            .withShutdownTimeout(30.minutes)
            .withRequestHeaderReceiveTimeout(30.minutes)
            .withMaxConnections(config.maximumServerConnection)
            .withHttpApp(app)
            .build
        } yield server)
          .use(_ => IO.never)
          .as(ExitCode.Success)
      }
 
========== End of src\main\scala\Process\Server.scala ========== 
 
========== src\main\scala\Utils\Test.scala ========== 
package Utils

import Common.API.PlanContext
import cats.effect.IO

object Test:
  def test(st:String)(using PlanContext):IO[String]=
    IO("hello world!")
 
========== End of src\main\scala\Utils\Test.scala ========== 
 
========== src\resources\application.conf ========== 
th = {
  connectionPool = "HikariCP" //use HikariCP for our connection pool
  dataSourceClass = "org.postgresql.ds.PGSimpleDataSource" //Simple datasource with no connection pooling. The connection pool has already been specified with HikariCP.
  properties = {
    serverName = "localhost"
    portNumber = "5432"
    databaseName = "tongwen"
    user = "db"
    password = "root"
  }
  numThreads = 10
}

 
========== End of src\resources\application.conf ========== 
 
======================================== 
Collection completed 
Total files processed: 103 
======================================== 
