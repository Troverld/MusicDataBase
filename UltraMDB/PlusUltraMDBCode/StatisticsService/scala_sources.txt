 
 
// ===== src\main\scala\Utils\GetCreatorCreationTendencyUtils.scala ===== 
 
package Utils

import Common.API.PlanContext
import APIs.MusicService.{FilterSongsByEntity, GetSongProfile}
import Objects.CreatorService.CreatorID_Type
import Objects.StatisticsService.{Dim, Profile}
import cats.effect.IO
import cats.implicits._
import org.slf4j.LoggerFactory
import io.circe.generic.auto._

object GetCreatorCreationTendencyUtils {

  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  /**
   * 生成创作者的创作倾向画像。
   * 这是核心业务逻辑，封装了获取作品、分析曲风和聚合计算的全过程。
   */
  def generateTendencyProfile(creator: CreatorID_Type, userID: String, userToken: String)(using planContext: PlanContext): IO[Profile] = {
    for {
      _ <- logInfo(s"在Utils层开始计算创作者 ${creator.id} 的创作倾向")
      
      // 步骤1: 获取创作者的所有作品ID
      songs <- getCreatorSongs(creator, userID, userToken)
      _ <- logInfo(s"获取到创作者作品 ${songs.length} 首")

      profile <- if (songs.isEmpty) {
        logInfo("创作者暂无作品，返回空倾向") >>
          IO.pure(Profile(List.empty, norm = true))
      } else {
        // 步骤2 & 3: 计算曲风分布并归一化
        for {
          unnormalizedProfile <- calculateGenreDistribution(songs, userID, userToken)
          _ <- logInfo(s"计算出未归一化的曲风分布: ${unnormalizedProfile.vector}")
          normalizedProfile = StatisticsUtils.normalizeVector(unnormalizedProfile)
        } yield normalizedProfile
      }
    } yield profile
  }

  /**
   * 内部辅助方法：调用API获取创作者的所有作品ID。
   */
  private def getCreatorSongs(creator: CreatorID_Type, userID: String, userToken: String)(using planContext: PlanContext): IO[List[String]] = {
    FilterSongsByEntity(userID, userToken, Some(creator)).send.flatMap {
      case (Some(songs), _) => IO.pure(songs)
      case (None, message) =>
        logInfo(s"获取创作者作品失败: $message. 将视为空列表处理。") >> IO.pure(List.empty)
    }
  }

  /**
   * 内部辅助方法：并行获取所有歌曲的曲风并聚合成一个未归一化的Profile。
   */
  private def calculateGenreDistribution(songs: List[String], userID: String, userToken: String)(using planContext: PlanContext): IO[Profile] = {
    // 并行获取每首歌的曲风向量
    songs.traverse { songId =>
      GetSongProfile(userID, userToken, songId).send.map {
        case (Some(profile), _) => profile.vector
        case (None, message) =>
          logger.warn(s"TID=${planContext.traceID.id} -- 获取歌曲 ${songId} 的Profile失败: $message. 将跳过此歌曲.")
          List.empty[Dim]
      }
    }.map { listOfVectors =>
      // 聚合所有曲风
      val allDims = listOfVectors.flatten
      val genreCounts = allDims
        .groupBy(_.GenreID)
        .view.mapValues(dims => dims.map(_.value).sum)
        .toList
        .map { case (genreId, count) => Dim(genreId, count) }
      Profile(genreCounts, norm = false)
    }
  }

  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] =
    IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\GetCreatorCreationTendencyUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\GetCreatorGenreStrengthUtils.scala ===== 
 
package Utils

import Common.API.PlanContext
import APIs.MusicService.{FilterSongsByEntity, GetSongProfile}
import Objects.CreatorService.CreatorID_Type
import Objects.StatisticsService.{Dim, Profile}
import cats.effect.IO
import cats.implicits._
import org.slf4j.LoggerFactory
import io.circe.generic.auto._

object GetCreatorGenreStrengthUtils {

  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  /**
   * 生成创作者的曲风实力画像。
   * 封装了获取作品、并行分析每首作品的属性、并聚合计算实力的全过程。
   */
  def generateStrengthProfile(creator: CreatorID_Type, userID: String, userToken: String)(using planContext: PlanContext): IO[Profile] = {
    for {
      _ <- logInfo(s"在Utils层开始计算创作者 ${creator.id} 的曲风实力")

      // **修正点**: 将 planContext 显式传递给辅助方法
      songs <- getCreatorSongs(creator, userID, userToken)(using planContext)
      _ <- logInfo(s"获取到创作者作品 ${songs.length} 首")

      strengthProfile <- if (songs.isEmpty) {
        logInfo("创作者暂无作品，返回空实力")(using planContext) >> // logInfo 也需要上下文
          IO.pure(Profile(List.empty, norm = false))
      } else {
        for {
          // **修正点**: 将 planContext 显式传递给辅助方法
          genreStrengthDims <- calculateGenreStrengths(songs, userID, userToken)(using planContext)
          _ <- logInfo(s"计算出曲风实力: ${genreStrengthDims}")(using planContext)
        } yield Profile(genreStrengthDims, norm = false)
      }
    } yield strengthProfile
  }

  /**
   * 内部辅助方法：获取创作者的所有作品ID列表。
   */
  private def getCreatorSongs(creator: CreatorID_Type, userID: String, userToken: String)(using planContext: PlanContext): IO[List[String]] = {
    FilterSongsByEntity(userID, userToken, Some(creator)).send.flatMap {
      case (Some(songs), _) => IO.pure(songs)
      case (None, message) =>
        logInfo(s"获取创作者作品失败: $message. 将视为空列表处理。")(using planContext) >> IO.pure(List.empty)
    }
  }

  /**
   * 内部辅助方法：计算各曲风的实力分数。
   */
  private def calculateGenreStrengths(songs: List[String], userID: String, userToken: String)(using planContext: PlanContext): IO[List[Dim]] = {
    for {
      // **修正点**: 将 planContext 显式传递给辅助方法
      songData <- songs.traverse(fetchSongData(_, userID, userToken)(using planContext))
      genreStrengths = calculateAveragePopularityByGenre(songData)
    } yield genreStrengths
  }

  /**
   * 内部辅助方法：并行获取单首歌曲的曲风和热度。
   */
  private def fetchSongData(songId: String, userID: String, userToken: String)(using planContext: PlanContext): IO[(List[String], Double)] = {
    // 使用 for-comprehension 保证串行执行
    for {
      // 外部API调用1：获取Profile
      profileResult <- GetSongProfile(userID, userToken, songId).send

      // 内部方法调用：获取Popularity (不再是API调用)
      // 这是关键的修复点
      popularity <- GetSongPopularityUtils.calculatePopularity(songId)

    } yield {
      val genres = profileResult match {
        case (Some(profile), _) => profile.vector.map(_.GenreID)
        case (None, msg) =>
          logger.warn(s"TID=${planContext.traceID.id} -- 获取歌曲 $songId 的Profile失败: $msg")
          List.empty[String]
      }
      (genres, popularity)
    }
  }

  /**
   * 内部辅助方法：按曲风计算平均热度（纯函数）。
   * **注意**: 此方法是纯函数，不执行任何IO或日志记录，因此它不需要 PlanContext。
   */
  private def calculateAveragePopularityByGenre(songData: List[(List[String], Double)]): List[Dim] = {
    val genrePopularities: List[(String, Double)] = for {
      (genres, popularity) <- songData if genres.nonEmpty && popularity > 0
      genre <- genres
    } yield (genre, popularity)

    genrePopularities
      .groupBy(_._1)
      .view
      .mapValues { popularities =>
        val scores = popularities.map(_._2)
        if (scores.isEmpty) 0.0 else scores.sum / scores.length
      }
      .toList
      .map { case (genreId, avgPopularity) => Dim(genreId, avgPopularity) }
  }

  // **修正点**: logInfo 的签名保持不变，但在调用时需要提供上下文
  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] =
    IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\GetCreatorGenreStrengthUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\GetNextSongRecommendationUtils.scala ===== 
 
// ===== src/main/scala/Utils/GetNextSongRecommendationUtils.scala =====

package Utils

import Common.API.PlanContext
import APIs.MusicService.{GetSongByID, GetSongProfile, FilterSongsByEntity}
import APIs.StatisticsService.{GetUserPortrait, GetSongPopularity, GetUserSongRecommendations}
import Objects.StatisticsService.{Dim, Profile}
import cats.effect.IO
import cats.implicits._
import io.circe.generic.auto._
import org.slf4j.LoggerFactory

object GetNextSongRecommendationUtils {

  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  // 超参数常量
  private val RECENT_SONGS_LIMIT = 10
  private val CANDIDATE_SONGS_LIMIT = 5
  private val TOP_N_SONGS_FOR_SAMPLING = 5
  private val FALLBACK_PAGE_SIZE = 20
  private val PREFERENCE_THRESHOLD = 0.05
  private val SOFTMAX_PREFERENCE_THRESHOLD = 0.2

  private type RecommendationStrategy = Set[String] => IO[Option[String]]

  def generateNextSongRecommendation(
      userID: String,
      userToken: String,
      currentSongID: String
  )(using planContext: PlanContext): IO[String] = {
    for {
      // 【串行】
      userPortrait <- getUserPortrait(userID, userToken)
      currentSongGenres <- getSongGenres(userID, userToken, currentSongID)
      recentPlayedSongs <- getRecentPlayedSongs(userID)
      _ <- logInfo(s"获取到用户画像，当前歌曲曲风: [${currentSongGenres.mkString(", ")}], 最近播放: ${recentPlayedSongs.size}首")

      strategies = List(
        recommendSameGenre(userID, userToken, currentSongGenres, userPortrait),
        recommendByUserTopGenre(userID, userToken, userPortrait),
        fallbackRecommendation(userID, userToken)
      )

      nextSongId <- tryStrategies(strategies, recentPlayedSongs + currentSongID)
    } yield nextSongId
  }

  private def getUserPortrait(userID: String, userToken: String)(using planContext: PlanContext): IO[Profile] =
    GetUserPortrait(userID, userToken).send.flatMap {
      case (Some(portrait), _) => IO.pure(portrait)
      case (None, msg) =>
        logInfo(s"无法获取用户画像: $msg. 将使用空画像。") >> IO.pure(Profile(List.empty, norm = true))
    }

  private def getSongGenres(userID: String, userToken: String, songId: String)(using planContext: PlanContext): IO[List[String]] =
    GetSongProfile(userID, userToken, songId).send.map {
      case (Some(profile), _) => profile.vector.map(_.GenreID)
      case (None, msg) =>
        logger.warn(s"TID=${planContext.traceID.id} -- 获取歌曲 $songId 的Profile失败: $msg. 将视为空曲风列表。")
        List.empty[String]
    }

  private def getRecentPlayedSongs(userID: String)(using PlanContext): IO[Set[String]] = {
    logInfo(s"正在调用SearchUtils查询用户最近播放的 ${RECENT_SONGS_LIMIT} 首歌曲")
    SearchUtils.fetchRecentPlayedSongs(userID, RECENT_SONGS_LIMIT)
  }

  private def tryStrategies(strategies: List[RecommendationStrategy], excludeSongs: Set[String])(using PlanContext): IO[String] =
    strategies.foldLeft(IO.pure(None: Option[String])) { (acc, strategy) =>
      acc.flatMap {
        case Some(songId) => IO.pure(Some(songId))
        case None => strategy(excludeSongs)
      }
    }.flatMap {
      case Some(songId) => IO.pure(songId)
      case None => IO.raiseError(new RuntimeException("所有推荐策略均失败，无法找到合适的歌曲"))
    }

  private def recommendSameGenre(userID: String, userToken: String, currentGenres: List[String], userPortrait: Profile)(using PlanContext): RecommendationStrategy = excludeSongs => {
    val genresWithPreference = currentGenres.flatMap(g => userPortrait.vector.find(_.GenreID == g))
    if (genresWithPreference.isEmpty) {
      logInfo("策略1: 用户对当前曲风无偏好记录，跳过") >> IO.pure(None)
    } else {
      val avgPreference = genresWithPreference.map(_.value).sum / genresWithPreference.length
      logInfo(s"策略1: 用户对当前曲风的平均偏好度为: $avgPreference")

      if (avgPreference >= PREFERENCE_THRESHOLD) {
        logInfo(s"偏好度高于阈值 $PREFERENCE_THRESHOLD, 准备从当前曲风中采样")
        val genreProfileToSample = Profile(vector = genresWithPreference, norm = false)
        StatisticsUtils.softmaxSample(genreProfileToSample) match {
          case Some(sampledGenre) =>
            logInfo(s"从当前歌曲曲风中采样选中: '$sampledGenre'")
            findSongInGenreByPopularity(userID, userToken, sampledGenre, excludeSongs)
          case None => IO.pure(None)
        }
      } else {
        logInfo(s"偏好度低于阈值 $PREFERENCE_THRESHOLD, 跳过") >> IO.pure(None)
      }
    }
  }

  private def recommendByUserTopGenre(userID: String, userToken: String, userPortrait: Profile)(using PlanContext): RecommendationStrategy = excludeSongs => {
    val highlyLikedGenres = userPortrait.vector.filter(_.value > SOFTMAX_PREFERENCE_THRESHOLD)
    if (highlyLikedGenres.isEmpty) {
      logInfo(s"策略2: 用户没有偏好度高于 ${SOFTMAX_PREFERENCE_THRESHOLD} 的曲风，跳过") >> IO.pure(None)
    } else {
      val likedGenresProfile = Profile(vector = highlyLikedGenres, norm = false)
      StatisticsUtils.softmaxSample(likedGenresProfile) match {
        case Some(sampledGenre) =>
          logInfo(s"策略2: 从 ${highlyLikedGenres.length} 个高偏好曲风中采样选中: '$sampledGenre'")
          findSongInGenreByPopularity(userID, userToken, sampledGenre, excludeSongs)
        case None => IO.pure(None)
      }
    }
  }

  private def fallbackRecommendation(userID: String, userToken: String)(using PlanContext): RecommendationStrategy = excludeSongs => {
    logInfo("策略3: 启动后备推荐策略")
    GetUserSongRecommendations(userID, userToken, pageSize = FALLBACK_PAGE_SIZE).send.flatMap {
      case (Some(recommendedIds), _) => IO.pure(recommendedIds.find(id => !excludeSongs.contains(id)))
      case (None, msg) => logInfo(s"后备推荐API调用失败: $msg").as(None)
    }
  }

  private def findSongInGenreByPopularity(userID: String, userToken: String, genre: String, excludeSongs: Set[String])(using PlanContext): IO[Option[String]] =
    for {
      candidateIds <- FilterSongsByEntity(userID, userToken, genres = Some(genre)).send.map(_._1.getOrElse(List.empty))
      candidates = candidateIds.filterNot(excludeSongs.contains).take(CANDIDATE_SONGS_LIMIT)
      songsWithPopularity <- candidates.traverse(songId => GetSongPopularity(userID, userToken, songId).send.map(r => (songId, r._1.getOrElse(0.0))))
      topSongs = songsWithPopularity.sortBy(-_._2).take(TOP_N_SONGS_FOR_SAMPLING)
      sampledSong <- if (topSongs.isEmpty) IO.pure(None) else {
        val songDims = topSongs.map { case (id, popularity) => Dim(id, popularity) }
        IO.pure(StatisticsUtils.softmaxSample(Profile(vector = songDims, norm = false)))
      }
    } yield sampledSong

  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] = IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\GetNextSongRecommendationUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\GetSimilarCreatorsUtils.scala ===== 
 
// ===== src/main/scala/Utils/GetSimilarCreatorsUtils.scala =====

package Utils

import Common.API.PlanContext
import APIs.CreatorService.GetAllCreators
import APIs.StatisticsService.{GetCreatorCreationTendency, GetCreatorGenreStrength}
import Objects.CreatorService.CreatorID_Type
import Objects.StatisticsService.Profile
import cats.effect.IO
import cats.implicits._
import org.slf4j.LoggerFactory
import io.circe.generic.auto._

object GetSimilarCreatorsUtils {

  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  private case class CreatorMetrics(creator: CreatorID_Type, tendency: Profile, strength: Profile)
  private case class RankedCreator(creator: CreatorID_Type, score: Double)

  def findSimilarCreators(
      userID: String,
      userToken: String,
      creator: CreatorID_Type,
      limit: Int
  )(using planContext: PlanContext): IO[List[CreatorID_Type]] = {
    for {
      _ <- logInfo("正在获取目标数据和所有候选创作者列表...")
      targetMetrics <- fetchCreatorMetrics(userID, userToken, creator)
      allOtherCreators <- fetchAllOtherCreators(userID, userToken, creator)
      _ <- logInfo(s"目标数据获取成功。找到 ${allOtherCreators.length} 位其他创作者。")

      _ <- logInfo("正在并行获取所有候选创作者的统计数据...")
      candidateMetrics <- fetchAllCandidateMetrics(userID, userToken, allOtherCreators)
      _ <- logInfo(s"成功获取了 ${candidateMetrics.length} 位候选创作者的数据。")

      _ <- logInfo("正在计算综合评分并排序...")
      rankedCreators = rankCreators(targetMetrics, candidateMetrics)

      finalResult = rankedCreators.take(limit)
      _ <- logInfo(s"查找完成，返回前 ${finalResult.length} 位最相似的创作者。")
    } yield finalResult.map(_.creator)
  }

  private def fetchCreatorMetrics(userID: String, userToken: String, c: CreatorID_Type)(using PlanContext): IO[CreatorMetrics] =
    for {
      tendencyResult <- GetCreatorCreationTendency(userID, userToken, c).send
      strengthResult <- GetCreatorGenreStrength(userID, userToken, c).send
      metrics <- (tendencyResult, strengthResult) match {
        case ((Some(tendency), _), (Some(strength), _)) =>
          IO.pure(CreatorMetrics(c, tendency, strength))
        case ((tendencyOpt, tendencyMsg), (strengthOpt, strengthMsg)) =>
          val errorDetails = s"Tendency: ${tendencyOpt.isDefined} ($tendencyMsg), Strength: ${strengthOpt.isDefined} ($strengthMsg)"
          IO.raiseError(new Exception(s"获取创作者 ${c.id} 的核心数据失败: $errorDetails"))
      }
    } yield metrics

  private def fetchAllOtherCreators(
                                     userID: String,
                                     userToken: String,
                                     targetCreator: CreatorID_Type
                                   )(using PlanContext): IO[List[CreatorID_Type]] =
    GetAllCreators(userID, userToken).send.flatMap {
      case (Some(all), _) => IO.pure(all.filterNot(_.id == targetCreator.id))
      case (None, msg) => IO.raiseError(new Exception(s"无法获取所有创作者列表: $msg"))
    }

  private def fetchAllCandidateMetrics(userID: String, userToken: String, candidates: List[CreatorID_Type])(using planContext: PlanContext): IO[List[CreatorMetrics]] =
    candidates.traverse { c =>
      fetchCreatorMetrics(userID, userToken, c).attempt.map {
        case Right(metrics) => Some(metrics)
        case Left(error) =>
          logger.warn(s"TID=${planContext.traceID.id} -- 获取候选者 ${c.id} 数据失败，将跳过此创作者: ${error.getMessage}")
          None
      }
    }.map(_.flatten)

  private def rankCreators(target: CreatorMetrics, candidates: List[CreatorMetrics]): List[RankedCreator] =
    candidates.map { candidate =>
      val similarity = StatisticsUtils.calculateCosineSimilarity(target.tendency, candidate.tendency)
      val totalStrength = candidate.strength.vector.map(_.value).sum
      val strengthFactor = Math.log1p(totalStrength)
      val finalScore = similarity * strengthFactor
      RankedCreator(candidate.creator, finalScore)
    }.filter(_.score > 0).sortBy(-_.score)

  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] = IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\GetSimilarCreatorsUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\GetSimilarSongsUtils.scala ===== 
 
// ===== src/main/scala/Utils/GetSimilarSongsUtils.scala =====

package Utils

import Common.API.PlanContext
import APIs.MusicService.{GetSongList, GetSongProfile}
import APIs.StatisticsService.GetSongPopularity
import Objects.StatisticsService.Profile
import cats.effect.IO
import cats.implicits._
import org.slf4j.LoggerFactory
import io.circe.generic.auto._

object GetSimilarSongsUtils {

  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  private case class SongMetrics(songID: String, profile: Profile, popularity: Double)
  private case class RankedSong(songID: String, score: Double)

  def findSimilarSongs(
      userID: String,
      userToken: String,
      songID: String,
      limit: Int
  )(using planContext: PlanContext): IO[List[String]] = {
    for {
      targetMetrics <- fetchSongMetrics(userID, userToken, songID)
      allOtherSongs <- fetchAllOtherSongs(userID, userToken, songID)
      _ <- logInfo(s"目标歌曲数据获取成功。找到 ${allOtherSongs.length} 首其他歌曲作为候选。")

      candidateMetrics <- fetchAllSongMetrics(userID, userToken, allOtherSongs)
      _ <- logInfo(s"成功获取了 ${candidateMetrics.length} 首候选歌曲的数据。")

      _ <- logInfo("正在计算综合推荐分并排序...")
      rankedSongs = rankSongs(targetMetrics, candidateMetrics)

      finalResult = rankedSongs.take(limit).map(_.songID)
      _ <- logInfo(s"查找完成，返回前 ${finalResult.length} 首最相似的歌曲。")
    } yield finalResult
  }

  private def fetchSongMetrics(userID: String, userToken: String, sID: String)(using PlanContext): IO[SongMetrics] =
    for {
      // 1. 串行执行两个 IO 操作
      profileResult <- GetSongProfile(userID, userToken, sID).send
      popularityResult <- GetSongPopularity(userID, userToken, sID).send

      // 2. 将两个结果组合成元组，然后对元组进行 match
      metrics <- (profileResult, popularityResult) match {
        // 匹配成功的情况
        case ((Some(profile), _), (Some(popularity), _)) =>
          IO.pure(SongMetrics(sID, profile, popularity))

        // 匹配失败的情况 (捕获所有其他组合)
        case ((profileOpt, profileMsg), (popOpt, popMsg)) =>
          val errorDetails = s"Profile: ${profileOpt.isDefined} ('$profileMsg'), Popularity: ${popOpt.isDefined} ('$popMsg')"
          IO.raiseError(new Exception(s"获取歌曲 ${sID} 的核心数据失败: $errorDetails"))
      }
    } yield metrics // 3. 将 match 的结果 (也是一个 IO) 返回

  private def fetchAllOtherSongs(userID: String, userToken: String, targetSongID: String)(using PlanContext): IO[List[String]] =
    GetSongList(userID, userToken).send.flatMap {
      case (Some(songIDs), _) => IO.pure(songIDs.filterNot(_ == targetSongID))
      case (None, msg) => IO.raiseError(new Exception(s"无法获取所有歌曲列表: $msg"))
    }

  private def fetchAllSongMetrics(userID: String, userToken: String, songIDs: List[String])(using planContext: PlanContext): IO[List[SongMetrics]] =
    songIDs.traverse { sID =>
      fetchSongMetrics(userID, userToken, sID).attempt.map {
        case Right(metrics) => Some(metrics)
        case Left(error) =>
          logger.warn(s"TID=${planContext.traceID.id} -- 获取候选歌曲 ${sID} 数据失败，将跳过此歌曲: ${error.getMessage}")
          None
      }
    }.map(_.flatten)

  private def rankSongs(target: SongMetrics, candidates: List[SongMetrics]): List[RankedSong] =
    candidates.map { candidate =>
      val matchScore = StatisticsUtils.calculateCosineSimilarity(target.profile, candidate.profile)
      val popularityFactor = Math.log1p(candidate.popularity)
      val finalScore = matchScore * popularityFactor
      RankedSong(candidate.songID, finalScore)
    }.filter(_.score > 0).sortBy(-_.score)

  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] = IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\GetSimilarSongsUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\GetSongPopularityUtils.scala ===== 
 
// file: Utils/GetSongPopularityUtils.scala
package Utils

import Common.API.PlanContext
import cats.effect.IO
import cats.implicits._

object GetSongPopularityUtils {

  /**
   * 计算一首歌的综合热度分数。
   * 这是一个核心业务逻辑，封装了热度的计算公式。
   *
   * @param songID 要计算热度的歌曲ID。
   * @param planContext 执行上下文。
   * @return 一个包含热度分数的IO。
   */
  def calculatePopularity(songID: String)(using planContext: PlanContext): IO[Double] = {
    // 这里的 for-comprehension 就是从 GetSongPopularityPlanner 中移动过来的
    for {
      // 步骤1: 调用数据访问层获取播放统计
      playCount <- SearchUtils.fetchPlayCount(songID)

      // 步骤2: 调用数据访问层获取评分统计
      (avgRating, ratingCount) <- SearchUtils.fetchAverageRating(songID)
      
      // 步骤3: 执行业务逻辑计算
      popularity = playCount * 0.7 + avgRating * ratingCount * 0.3
      
    } yield popularity
  }

  // 未来可以添加更多类似的可复用业务流程...
  // def recommendSimilarSongs(songID: String): IO[List[Song]] = { ... }
} 
// ===== End of src\main\scala\Utils\GetSongPopularityUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\GetUserPortraitUtils.scala ===== 
 
package Utils

import Common.API.PlanContext
import APIs.MusicService.{GetMultSongsProfiles, GetSongProfile}
import Objects.StatisticsService.{Dim, Profile}
import cats.effect.IO
import cats.implicits._
import org.slf4j.LoggerFactory
import io.circe.generic.auto._

object GetUserPortraitUtils {
  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  def generateUserProfile(userID: String, userToken: String)(using planContext: PlanContext): IO[Profile] = {
    // 权重系数，方便调整
    val ratingWeightCoefficient = 10.0

    for {
      _ <- logInfo("开始实时计算用户画像")

      // 1. 调用数据访问层获取历史记录
      playedSongs <- SearchUtils.fetchUserPlaybackHistory(userID)
      ratedSongsMap <- SearchUtils.fetchUserRatingHistory(userID)

      allInteractedSongIds = (playedSongs ++ ratedSongsMap.keys).toSet
      _ <- logInfo(s"用户总共交互过 ${allInteractedSongIds.size} 首歌曲")

      profile <- if (allInteractedSongIds.isEmpty) {
        logInfo("用户暂无交互记录，返回空画像") >>
          IO.pure(Profile(List.empty, norm = true))
      } else {
        // 2. 计算每首歌的交互分数
        val songInteractionScores = allInteractedSongIds.map { songId =>
          val ratingBonus = ratedSongsMap.get(songId).map(rating => (rating - 3.0) * ratingWeightCoefficient).getOrElse(0.0)
          val interactionScore = 1.0 + ratingBonus
          (songId, interactionScore)
        }.toMap

        for {
          // 3. 并行获取所有歌曲的Profile
          songProfilesMap <- fetchGenresForSongs(allInteractedSongIds, userID, userToken)

          // 4. 计算加权Profile总和
          rawProfile = mapReduceGenreScores(songInteractionScores, songProfilesMap)

          // 5. 归一化
          finalProfile = StatisticsUtils.normalizeVector(rawProfile)

          _ <- logInfo(s"计算出用户画像，包含 ${finalProfile.vector.length} 个曲风偏好")
        } yield finalProfile
      }
    } yield profile
  }

  private def mapReduceGenreScores(
    songScores: Map[String, Double],
    genreMap: Map[String, Profile]  // Changed from Map[String, List[String]]
  ): Profile = {
    songScores.foldLeft(Profile(List.empty, norm = false)) {
      case (accumulatedProfile, (songId, score)) =>
        genreMap.get(songId) match {
          case Some(songProfile) =>
            val weightedProfile = StatisticsUtils.multiply(songProfile, score)
            StatisticsUtils.add(accumulatedProfile, weightedProfile)
          case None =>
            accumulatedProfile
        }
    }
  }

  private def fetchGenresForSongs(songIds: Set[String], userID: String, userToken: String)(using planContext: PlanContext): IO[Map[String, Profile]] = {
    if (songIds.isEmpty) return IO.pure(Map.empty)

    logInfo(s"准备批量获取 ${songIds.size} 首歌曲的曲风Profile")

    val songIdsList = songIds.toList

    GetMultSongsProfiles(userID, userToken, songIdsList).send.flatMap {
      case (Some(profiles), _) =>
        IO.pure(songIdsList.zip(profiles).toMap)
      
      case (None, message) =>
        logInfo(s"批量获取歌曲Profile失败: $message. 将回退到单曲获取方式") >>
          songIds.toList.traverse { songId =>
            GetSongProfile(userID, userToken, songId).send.map {
              case (Some(profile), _) => songId -> profile
              case (None, message) =>
                logger.warn(s"TID=${planContext.traceID.id} -- 获取歌曲 $songId 的Profile失败: $message. 该歌曲的曲风贡献将为空。")
                songId -> Profile(List.empty, norm = true)
            }
          }.map(_.toMap)
    }
  }
  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] =
    IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\GetUserPortraitUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\GetUserSongRecommendationsUtils.scala ===== 
 
package Utils

import Common.API.PlanContext
import APIs.StatisticsService.{GetUserPortrait, GetSongPopularity}
import APIs.MusicService.{GetSongList, GetSongProfile}
import Objects.StatisticsService.Profile
import cats.effect.IO
import cats.implicits._
import io.circe.generic.auto._
import org.slf4j.LoggerFactory

object GetUserSongRecommendationsUtils {
  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  // -- 辅助数据结构 --
  private case class SongMetrics(songID: String, profile: Profile, popularity: Double)
  private case class RankedSong(songID: String, score: Double)

  def generateRecommendations(userID: String, userToken: String, pageNumber: Int, pageSize: Int)(using planContext: PlanContext): IO[List[String]] = {
    for {
      _ <- logInfo(s"在Utils层开始为用户 ${userID} 生成推荐，页码: ${pageNumber}，每页: ${pageSize}")

      userPortrait <- fetchUserPortrait(userID, userToken)
      allSongs <- fetchAllCandidateSongs(userID, userToken)

      rankedSongs <- if (userPortrait.vector.isEmpty) {
        logInfo("用户暂无画像数据，将推荐热门歌曲。") >> rankSongsByPopularity(allSongs, userID, userToken)
      } else {
        for {
          _ <- logInfo(s"用户画像获取成功。找到 ${allSongs.length} 首候选歌曲，开始计算个性化推荐...")
          candidateMetrics <- fetchAllSongMetrics(allSongs, userID, userToken)
          _ <- logInfo(s"成功获取了 ${candidateMetrics.length} 首候选歌曲的数据。")
          ranked = rankSongsBySimilarity(userPortrait, candidateMetrics)
        } yield ranked
      }

      paginatedResults = paginate(rankedSongs.map(_.songID), pageNumber, pageSize)
    } yield paginatedResults
  }

  private def fetchUserPortrait(userID: String, userToken: String)(using planContext: PlanContext): IO[Profile] =
    GetUserPortrait(userID, userToken).send.flatMap {
      case (Some(portrait), _) => IO.pure(portrait)
      case (None, msg) => logInfo(s"无法获取用户画像: $msg. 将使用空画像。") >> IO.pure(Profile(List.empty, norm = true))
    }

  private def fetchAllCandidateSongs(userID: String, userToken: String)(using planContext: PlanContext): IO[List[String]] =
    GetSongList(userID, userToken).send.flatMap {
      case (Some(songs), _) => IO.pure(songs)
      case (None, msg) => IO.raiseError(new Exception(s"无法获取所有歌曲列表: $msg"))
    }

  private def fetchAllSongMetrics(songIDs: List[String], userID: String, userToken: String)(using planContext: PlanContext): IO[List[SongMetrics]] =
    SearchUtils.fetchUserPlayedSongIds(userID).flatMap { playedSongs =>
      val songsToFetch = songIDs.filterNot(playedSongs.contains)
      logInfo(s"用户已听过 ${playedSongs.size} 首歌，将从 ${songsToFetch.length} 首未听过的歌曲中获取数据。")

      songsToFetch.traverse { songID =>
        fetchSongMetrics(songID, userID, userToken).attempt.map {
          case Right(metrics) => Some(metrics)
          case Left(error) =>
            logger.warn(s"TID=${planContext.traceID.id} -- 获取歌曲 ${songID} 数据失败，跳过: ${error.getMessage}")
            None
        }
      }.map(_.flatten)
    }

  private def fetchSongMetrics(songID: String, userID: String, userToken: String)(using planContext: PlanContext): IO[SongMetrics] =
    for {
      // 串行执行两个 IO 操作
      profileResult <- GetSongProfile(userID, userToken, songID).send
      popularityResult <- GetSongPopularity(userID, userToken, songID).send

      // 对两个操作的结果元组进行 match
      metrics <- (profileResult, popularityResult) match {
        // 成功情况：两个 API 都返回了 Some(...)
        case ((Some(profile), _), (Some(popularity), _)) =>
          IO.pure(SongMetrics(songID, profile, popularity))

        // 失败情况：任何一个或两个 API 调用失败
        case ((profileOpt, profileMsg), (popOpt, popMsg)) =>
          val errorDetails = s"Profile: ${profileOpt.isDefined} ('$profileMsg'), Popularity: ${popOpt.isDefined} ('$popMsg')"
          IO.raiseError(new Exception(s"获取歌曲 ${songID} 的核心数据失败: $errorDetails"))
      }
    } yield metrics

  private def rankSongsBySimilarity(userPortrait: Profile, candidates: List[SongMetrics]): List[RankedSong] = {
    candidates.map { song =>
      val matchScore = StatisticsUtils.calculateCosineSimilarity(userPortrait, song.profile)
      val popularityFactor = Math.log1p(song.popularity)
      val finalScore = matchScore * popularityFactor
      RankedSong(song.songID, finalScore)
    }.filter(_.score > 0).sortBy(-_.score)
  }

  private def rankSongsByPopularity(songIDs: List[String], userID: String, userToken: String)(using planContext: PlanContext): IO[List[RankedSong]] = {
    logInfo("正在并行获取所有歌曲的热度以进行热门推荐...")
    songIDs.traverse { songID =>
      GetSongPopularity(userID, userToken, songID).send
        .map(r => RankedSong(songID, r._1.getOrElse(0.0)))
        .attempt // Use attempt to prevent one failure from failing all
    }.map { results =>
      results.collect { case Right(rankedSong) if rankedSong.score > 0 => rankedSong }.sortBy(-_.score)
    }
  }

  private def paginate(recommendations: List[String], pageNumber: Int, pageSize: Int): List[String] = {
    val startIndex = (pageNumber - 1) * pageSize
    recommendations.slice(startIndex, startIndex + pageSize)
  }

  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] = IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\GetUserSongRecommendationsUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\RateSongUtils.scala ===== 
 
package Utils

import Common.API.PlanContext
import cats.effect.IO
import cats.implicits._
import org.slf4j.LoggerFactory

object RateSongUtils {
  private val logger = LoggerFactory.getLogger(getClass.getSimpleName)

  /**
   * 核心业务逻辑：保存或更新用户对歌曲的评分。
   * 封装了“读后写”的完整流程。
   */
  def rateSong(userID: String, songID: String, rating: Int)(using planContext: PlanContext): IO[Unit] = {
    for {
      _ <- logInfo(s"在Utils层开始处理评分逻辑，用户: ${userID}, 歌曲: ${songID}")
      
      // 步骤1: 调用DAO层检查是否存在现有评分
      existingRatingOpt <- SearchUtils.fetchUserSongRating(userID, songID)

      // 步骤2: 根据是否存在，决定是更新还是插入
      _ <- existingRatingOpt match {
        case Some(oldRating) =>
          logInfo(s"更新现有评分，原评分: ${oldRating}，新评分: ${rating}") >>
            SearchUtils.updateUserSongRating(userID, songID, rating)
        case None =>
          logInfo("插入新的评分记录") >>
            SearchUtils.insertUserSongRating(userID, songID, rating)
      }
      _ <- logInfo("评分记录已在数据库中保存")
    } yield ()
  }
  
  private def logInfo(message: String)(using pc: PlanContext): IO[Unit] =
    IO(logger.info(s"TID=${pc.traceID.id} -- $message"))
} 
// ===== End of src\main\scala\Utils\RateSongUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\SearchUtils.scala ===== 
 
// ===== src/main/scala/Utils/SearchUtils.scala =====

// file: Utils/SearchUtils.scala
package Utils

import Common.DBAPI._
import Common.Object.SqlParameter
import Common.ServiceUtils.schemaName
import cats.effect.IO
import io.circe.generic.auto._
import Common.API.PlanContext
import cats.implicits._
import org.joda.time.DateTime

object SearchUtils {

  // ... [已有代码保持不变] ...
  def fetchAverageRating(songID: String)(using planContext: PlanContext): IO[(Double, Int)] = {
    val sql = s"SELECT AVG(rating) AS avg_rating, COUNT(rating) AS rating_count FROM ${schemaName}.song_rating WHERE song_id = ?"
    val params = List(SqlParameter("String", songID))

    readDBRows(sql, params).flatMap {
      case row :: Nil =>
        // 使用 for-comprehension 和 IO.fromEither 安全地解码，参考了范例的最佳实践
        for {
          avgRatingOpt <- IO.fromEither(row.hcursor.get[Option[Double]]("avgRating")
            .leftMap(err => new Exception(s"解码 avgRating 失败: ${err.getMessage}", err)))
          ratingCount <- IO.fromEither(row.hcursor.get[Int]("ratingCount")
            .leftMap(err => new Exception(s"解码 ratingCount 失败: ${err.getMessage}", err)))
        } yield (avgRatingOpt.getOrElse(0.0), ratingCount)
      case _ =>
        // 如果没有评分记录，则平均分和评分数都为0
        IO.pure((0.0, 0))
    }
  }

  def fetchPlayCount(songID: String)(using planContext: PlanContext): IO[Int] = {
    val sql = s"SELECT COUNT(*) FROM ${schemaName}.playback_log WHERE song_id = ?"
    readDBInt(sql, List(SqlParameter("String", songID)))
  }

  def fetchUserPlaybackHistory(userID: String)(using planContext: PlanContext): IO[List[String]] = {
    val sql = s"SELECT song_id FROM ${schemaName}.playback_log WHERE user_id = ?"
    val params = List(SqlParameter("String", userID))

    readDBRows(sql, params).flatMap { rows =>
      rows.traverse { row =>
        IO.fromEither(
          // 修正：根据规范，song_id 应当解码为 songID
          row.hcursor.get[String]("songID")
            .leftMap(err => new Exception(s"解码 playback_log.songID 失败: ${err.getMessage}", err))
        )
      }
    }
  }

  /**
   * (新增方法)
   * 从数据库获取用户最近播放的歌曲ID集合。
   *
   * @param userID 目标用户的ID。
   * @param limit  要获取的歌曲数量。
   * @return 一个包含最近播放歌曲ID的Set的IO。
   */
  def fetchRecentPlayedSongs(userID: String, limit: Int)(using planContext: PlanContext): IO[Set[String]] = {
    val sql = s"SELECT song_id FROM ${schemaName}.playback_log WHERE user_id = ? ORDER BY play_time DESC LIMIT ?"
    readDBRows(sql, List(SqlParameter("String", userID), SqlParameter("Int", limit.toString)))
      .flatMap { rows =>
        rows.traverse { row =>
          IO.fromEither(
            // 修正：根据规范，song_id 应当解码为 songID
            row.hcursor.get[String]("songID")
              .leftMap(err => new Exception(s"解码 playback_log.songID 失败: ${err.getMessage}", err))
          )
        }
      }.map(_.toSet)
  }

  def fetchUserRatingHistory(userID: String)(using planContext: PlanContext): IO[Map[String, Int]] = {
    val sql = s"SELECT song_id, rating FROM ${schemaName}.song_rating WHERE user_id = ?"
    val params = List(SqlParameter("String", userID))

    readDBRows(sql, params).flatMap { rows =>
      val decodedPairsIO = rows.traverse { row =>
        for {
          songId <- IO.fromEither(
            // 修正：根据规范，song_id 应当解码为 songID
            row.hcursor.get[String]("songID")
              .leftMap(err => new Exception(s"解码 song_rating.songID 失败: ${err.getMessage}", err))
          )
          rating <- IO.fromEither(
            row.hcursor.get[Int]("rating")
              .leftMap(err => new Exception(s"解码 song_rating.rating 失败: ${err.getMessage}", err))
          )
        } yield (songId, rating)
      }
      decodedPairsIO.map(_.toMap)
    }
  }

  def fetchUserPlayedSongIds(userID: String)(using planContext: PlanContext): IO[Set[String]] = {
    val sql = s"SELECT DISTINCT song_id FROM ${schemaName}.playback_log WHERE user_id = ?"
    val params = List(SqlParameter("String", userID))

    readDBRows(sql, params).flatMap { rows =>
      rows.traverse { row =>
        IO.fromEither(
          // 修正：根据规范，song_id 应当解码为 songID
          row.hcursor.get[String]("songID")
            .leftMap(err => new Exception(s"解码 playback_log.songID 失败: ${err.getMessage}", err))
        )
      }.map(_.toSet)
    }
  }

  def logPlayback(userID: String, songID: String)(using planContext: PlanContext): IO[Unit] = {
    for {
      now <- IO(new DateTime())
      logId <- IO(java.util.UUID.randomUUID().toString)
      sql = s"INSERT INTO ${schemaName}.playback_log (log_id, user_id, song_id, play_time) VALUES (?, ?, ?, ?)"
      params = List(
        SqlParameter("String", logId),
        SqlParameter("String", userID),
        SqlParameter("String", songID),
        SqlParameter("DateTime", now.getMillis.toString)
      )
      _ <- writeDB(sql, params)
    } yield ()
  }

  def fetchUserSongRating(userID: String, songID: String)(using planContext: PlanContext): IO[Option[Int]] = {
    val sql = s"SELECT rating FROM ${schemaName}.song_rating WHERE user_id = ? AND song_id = ?"
    val params = List(SqlParameter("String", userID), SqlParameter("String", songID))

    readDBRows(sql, params).flatMap {
      case row :: _ => IO.fromEither(row.hcursor.get[Int]("rating")).map(Some(_))
      case Nil => IO.pure(None)
    }
  }

  def updateUserSongRating(userID: String, songID: String, rating: Int)(using planContext: PlanContext): IO[Unit] = {
    val sql = s"UPDATE ${schemaName}.song_rating SET rating = ?, rated_at = ? WHERE user_id = ? AND song_id = ?"
    for {
      now <- IO(new DateTime())
      _ <- writeDB(sql, List(
        SqlParameter("Int", rating.toString),
        SqlParameter("DateTime", now.getMillis.toString),
        SqlParameter("String", userID),
        SqlParameter("String", songID)
      ))
    } yield ()
  }

  def insertUserSongRating(userID: String, songID: String, rating: Int)(using planContext: PlanContext): IO[Unit] = {
    val sql = s"INSERT INTO ${schemaName}.song_rating (user_id, song_id, rating, rated_at) VALUES (?, ?, ?, ?)"
    for {
      now <- IO(new DateTime())
      _ <- writeDB(sql, List(
        SqlParameter("String", userID),
        SqlParameter("String", songID),
        SqlParameter("Int", rating.toString),
        SqlParameter("DateTime", now.getMillis.toString)
      ))
    } yield ()
  }
} 
// ===== End of src\main\scala\Utils\SearchUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\StatisticsUtils.scala ===== 
 
package Utils

import Objects.StatisticsService.{Dim, Profile} // 确保 Dim 也被导入
import scala.math.{exp, sqrt}
import scala.util.Random

object StatisticsUtils {

  /**
   * 计算两个Profile向量的余弦相似度。
   * @param profileA Profile A
   * @param profileB Profile B
   * @return 余弦相似度值，范围 [0, 1]
   */
  def calculateCosineSimilarity(profileA: Profile, profileB: Profile): Double = {
    // 修正: List[Dim] 不能直接 toMap，需要手动转换为 Map[String, Double]
    val mapA = profileA.vector.map(dim => (dim.GenreID, dim.value)).toMap
    val mapB = profileB.vector.map(dim => (dim.GenreID, dim.value)).toMap
    
    val commonKeys = mapA.keySet.intersect(mapB.keySet)
    
    if (commonKeys.isEmpty) return 0.0
    
    val dotProduct = commonKeys.map(key => mapA.getOrElse(key, 0.0) * mapB.getOrElse(key, 0.0)).sum
    val magnitudeA = sqrt(mapA.values.map(v => v * v).sum)
    val magnitudeB = sqrt(mapB.values.map(v => v * v).sum)
    
    if (magnitudeA == 0.0 || magnitudeB == 0.0) 0.0
    else dotProduct / (magnitudeA * magnitudeB)
  }

  /**
   * 归一化一个Profile的向量，使其所有值的和为1.0。
   * 如果该Profile已经是归一化的，则直接返回。
   * @param profile 待归一化的Profile
   * @return 一个新的、向量被归一化后的Profile
   */
  def normalizeVector(profile: Profile): Profile = {
    if (profile.norm) return profile
    
    val vector = profile.vector
    // 修正: 从元组的 ._2 改为 Dim 对象的 .value
    val sum = vector.map(_.value).sum
    
    val normalizedVector = if (sum == 0.0) {
      vector
    } else {
      // 修正: 不再创建元组，而是创建新的 Dim 对象
      vector.map { dim => dim.copy(value = dim.value / sum) }
    }
    
    Profile(normalizedVector, norm = true)
  }

  /**
   * 内部实现的Softmax加权随机抽样。
   * 这个方法是私有的，只能在 StatisticsUtils 内部被调用。
   */
  private def softmaxSampleInternal[A](itemsWithScores: List[(A, Double)]): Option[A] = {
    if (itemsWithScores.isEmpty) return None
    
    val validItems = itemsWithScores.filter(_._2 > 0)
    if (validItems.isEmpty) return itemsWithScores.headOption.map(_._1)

    val expScores = validItems.map { case (_, score) => exp(score) }
    val sumExpScores = expScores.sum

    if (sumExpScores == 0 || sumExpScores.isInfinite || sumExpScores.isNaN) {
      return validItems.headOption.map(_ => validItems(Random.nextInt(validItems.length))._1)
    }

    val probabilities = expScores.map(_ / sumExpScores)
    val cumulativeProbabilities = probabilities.scanLeft(0.0)(_ + _).tail
    val randomDouble = Random.nextDouble()
    val chosenIndex = cumulativeProbabilities.indexWhere(_ >= randomDouble)

    if (chosenIndex != -1) Some(validItems(chosenIndex)._1)
    else validItems.lastOption.map(_._1)
  }

  /**
   * 对一个Profile的向量进行Softmax加权随机抽样。
   * 这是Softmax抽样的唯一公共接口。
   * @param profile 包含(GenreID, PreferenceScore)向量的Profile。
   * @return 抽样选中的一个GenreID，如果向量为空则返回None。
   */
  def softmaxSample(profile: Profile): Option[String] = {
    // 修正: 将 List[Dim] 转换为 List[(String, Double)] 以调用内部实现
    val itemsWithScores = profile.vector.map(dim => (dim.GenreID, dim.value))
    softmaxSampleInternal(itemsWithScores)
  }

  /**
   * Multiplies a Profile by a scalar value
   * @param profile The profile to multiply
   * @param scalar The scalar value
   * @return A new Profile with all dimensions multiplied by the scalar
   */
  def multiply(profile: Profile, scalar: Double): Profile = {
    Profile(
      profile.vector.map(dim => dim.copy(value = dim.value * scalar)),
      profile.norm && scalar == 1.0  // Only remains normalized if scalar is 1
    )
  }

  /**
   * Adds two profiles together (vector addition)
   * @param profile1 First profile
   * @param profile2 Second profile
   * @return A new Profile that's the sum of both inputs
   */
  def add(profile1: Profile, profile2: Profile): Profile = {
    val map1 = profile1.vector.map(dim => (dim.GenreID, dim.value)).toMap
    val map2 = profile2.vector.map(dim => (dim.GenreID, dim.value)).toMap

    val allKeys = map1.keySet ++ map2.keySet
    val summedVector = allKeys.toList.map { key =>
      Dim(key, map1.getOrElse(key, 0.0) + map2.getOrElse(key, 0.0))
    }

    Profile(
      summedVector,
      norm = false // Sum of normalized vectors isn't necessarily normalized
    )
  }
} 
// ===== End of src\main\scala\Utils\StatisticsUtils.scala ===== 
 
 
// ===== src\main\scala\Utils\Test.scala ===== 
 
package Utils

import Common.API.PlanContext
import cats.effect.IO

object Test:
  def test(st:String)(using PlanContext):IO[String]=
    IO("hello world!")
 
// ===== End of src\main\scala\Utils\Test.scala ===== 
 
 
// ======================================== 
// Collection completed 
// Total .scala files processed: 12 
// ======================================== 
